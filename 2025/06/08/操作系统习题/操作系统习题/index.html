<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>操作系统习题 | PIQUE</title><meta name="author" content="PIQUE"><meta name="copyright" content="PIQUE"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 第1章 介绍1.1. 操作系统的三个主要目的是什么？ 提供一个环境，使计算机用户能够在计算机硬件上以方便且高效的方式执行程序。   根据需要分配计算机的各个资源，以执行所需任务。分配过程应尽可能公正和高效。   作为控制程序，它有两个主要功能：（1）监督用户程序的执行，以防止错误和不当使用计算机；（2）管理 I&#x2F;O 设备的操作和控制。  1.2. 我们强调了操作系统高效利用计算硬件的必要性。">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统习题">
<meta property="og:url" content="http://example.com/2025/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%A0%E9%A2%98/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%A0%E9%A2%98/index.html">
<meta property="og:site_name" content="PIQUE">
<meta property="og:description" content="1. 第1章 介绍1.1. 操作系统的三个主要目的是什么？ 提供一个环境，使计算机用户能够在计算机硬件上以方便且高效的方式执行程序。   根据需要分配计算机的各个资源，以执行所需任务。分配过程应尽可能公正和高效。   作为控制程序，它有两个主要功能：（1）监督用户程序的执行，以防止错误和不当使用计算机；（2）管理 I&#x2F;O 设备的操作和控制。  1.2. 我们强调了操作系统高效利用计算硬件的必要性。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/image/image1.png">
<meta property="article:published_time" content="2025-06-08T14:19:00.000Z">
<meta property="article:modified_time" content="2025-06-08T11:15:34.806Z">
<meta property="article:author" content="PIQUE">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/image/image1.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "操作系统习题",
  "url": "http://example.com/2025/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%A0%E9%A2%98/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%A0%E9%A2%98/",
  "image": "http://example.com/image/image1.png",
  "datePublished": "2025-06-08T14:19:00.000Z",
  "dateModified": "2025-06-08T11:15:34.806Z",
  "author": [
    {
      "@type": "Person",
      "name": "PIQUE",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%A0%E9%A2%98/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%A0%E9%A2%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统习题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/./image/image1.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清單</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(./image/background.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">PIQUE</span></a><a class="nav-page-title" href="/"><span class="site-name">操作系统习题</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清單</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">操作系统习题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-08T14:19:00.000Z" title="发表于 2025-06-08 22:19:00">2025-06-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-08T11:15:34.806Z" title="更新于 2025-06-08 19:15:34">2025-06-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="1-第1章-介绍"><a href="#1-第1章-介绍" class="headerlink" title="1. 第1章 介绍"></a>1. 第1章 介绍</h2><h3 id="1-1-操作系统的三个主要目的是什么？"><a href="#1-1-操作系统的三个主要目的是什么？" class="headerlink" title="1.1. 操作系统的三个主要目的是什么？"></a>1.1. 操作系统的三个主要目的是什么？</h3><ul>
<li>提供一个环境，使计算机用户能够在计算机硬件上以方便且高效的方式执行程序。  </li>
<li>根据需要分配计算机的各个资源，以执行所需任务。分配过程应尽可能公正和高效。  </li>
<li>作为控制程序，它有两个主要功能：（1）监督用户程序的执行，以防止错误和不当使用计算机；（2）管理 I/O 设备的操作和控制。</li>
</ul>
<h3 id="1-2-我们强调了操作系统高效利用计算硬件的必要性。在什么情况下操作系统应该放弃这一原则，去“浪费”资源？为什么这种系统实际上并不浪费资源？"><a href="#1-2-我们强调了操作系统高效利用计算硬件的必要性。在什么情况下操作系统应该放弃这一原则，去“浪费”资源？为什么这种系统实际上并不浪费资源？" class="headerlink" title="1.2. 我们强调了操作系统高效利用计算硬件的必要性。在什么情况下操作系统应该放弃这一原则，去“浪费”资源？为什么这种系统实际上并不浪费资源？"></a>1.2. 我们强调了操作系统高效利用计算硬件的必要性。在什么情况下操作系统应该放弃这一原则，去“浪费”资源？为什么这种系统实际上并不浪费资源？</h3><p><strong>单用户系统</strong>应该最大化系统的使用以供用户使用。一个 <strong>GUI</strong> 可能“浪费”CPU周期，但它优化了用户与系统的交互。</p>
<p><strong>例如在Openwrt系统中</strong>，这是典型的单用户场景，为了追求性能，通常是不需要GUI的。</p>
<h3 id="1-3-在为实时环境编写操作系统时，程序员必须克服的主要困难是什么？"><a href="#1-3-在为实时环境编写操作系统时，程序员必须克服的主要困难是什么？" class="headerlink" title="1.3. 在为实时环境编写操作系统时，程序员必须克服的主要困难是什么？"></a>1.3. 在为实时环境编写操作系统时，程序员必须克服的主要困难是什么？</h3><p>主要困难是让操作系统在实时系统的固定时间限制内运行。如果系统在某个时间框架内未完成任务，可能会导致整个系统的崩溃。因此，在为实时系统编写操作系统时，程序员必须确保其调度方案不会使响应时间超过时间限制。</p>
<h3 id="1-4-考虑操作系统的各种定义，是否应该将应用程序如网页浏览器和邮件程序包含在操作系统中？请分别支持和反对的论点。"><a href="#1-4-考虑操作系统的各种定义，是否应该将应用程序如网页浏览器和邮件程序包含在操作系统中？请分别支持和反对的论点。" class="headerlink" title="1.4. 考虑操作系统的各种定义，是否应该将应用程序如网页浏览器和邮件程序包含在操作系统中？请分别支持和反对的论点。"></a>1.4. 考虑操作系统的各种定义，是否应该将应用程序如网页浏览器和邮件程序包含在操作系统中？请分别支持和反对的论点。</h3><p><strong>支持将流行应用程序包含在操作系统中的论点</strong>是，如果应用程序嵌入操作系统，它可能更好地利用内核中的特性，从而在性能上优于运行在内核外的应用程序。<br>然而，通常反对将应用程序嵌入操作系统的论点占主导地位：（1）这些应用程序是应用程序—而不是操作系统的一部分，（2）运行在内核中的任何性能优势都被安全漏洞所抵消，（3）应用程序的包含会导致操作系统膨胀。</p>
<h3 id="1-5-内核模式和用户模式的区分如何作为保护（安全）的基础形式起作用？"><a href="#1-5-内核模式和用户模式的区分如何作为保护（安全）的基础形式起作用？" class="headerlink" title="1.5. 内核模式和用户模式的区分如何作为保护（安全）的基础形式起作用？"></a>1.5. 内核模式和用户模式的区分如何作为保护（安全）的基础形式起作用？</h3><p><strong>内核模式</strong>和<strong>用户模式</strong>的区分提供了一种基础的保护形式。某些指令只能在 <strong>内核模式</strong> 下执行。类似地，硬件设备只有在程序处于 <strong>内核模式</strong> 时才能访问，并且中断只能在 <strong>内核模式</strong> 下启用或禁用。因此，<strong>CPU</strong> 在 <strong>用户模式</strong> 下的功能非常有限，从而加强了对关键资源的保护。</p>
<h3 id="1-6-以下哪些指令应该是特权指令？"><a href="#1-6-以下哪些指令应该是特权指令？" class="headerlink" title="1.6. 以下哪些指令应该是特权指令？"></a>1.6. 以下哪些指令应该是特权指令？</h3><p>a) 设置定时器值。<br>b) 读取时钟。<br>c) 清除内存。<br>d) 发出陷阱指令。<br>e) 关闭中断。<br>f) 修改设备状态表中的条目。<br>g) 从用户模式切换到内核模式。<br>h) 访问 I/O 设备。  </p>
<p><strong>a)</strong>、<strong>c)</strong>、<strong>e)</strong>、<strong>f)</strong>、<strong>h)</strong></p>
<p>需要特权的操作包括：设置定时器值、清除内存、关闭中断、修改设备状态表中的条目、访问 I/O 设备。其余可以在用户模式下执行。</p>
<h3 id="1-7-一些早期的计算机通过将操作系统放置在一个内存分区中来保护操作系统，该分区既不能被用户作业也不能被操作系统本身修改。描述这种方案可能带来的两种困难。"><a href="#1-7-一些早期的计算机通过将操作系统放置在一个内存分区中来保护操作系统，该分区既不能被用户作业也不能被操作系统本身修改。描述这种方案可能带来的两种困难。" class="headerlink" title="1.7. 一些早期的计算机通过将操作系统放置在一个内存分区中来保护操作系统，该分区既不能被用户作业也不能被操作系统本身修改。描述这种方案可能带来的两种困难。"></a>1.7. 一些早期的计算机通过将操作系统放置在一个内存分区中来保护操作系统，该分区既不能被用户作业也不能被操作系统本身修改。描述这种方案可能带来的两种困难。</h3><ul>
<li>操作系统所需的数据（如密码、访问控制、会计信息等）必须存储在或传递通过未保护的内存中，因此这些数据对未经授权的用户可见。</li>
</ul>
<h3 id="1-8-一些-CPU-提供了多于两种的操作模式。以下是这几种模式的两种可能用途："><a href="#1-8-一些-CPU-提供了多于两种的操作模式。以下是这几种模式的两种可能用途：" class="headerlink" title="1.8. 一些 CPU 提供了多于两种的操作模式。以下是这几种模式的两种可能用途："></a>1.8. 一些 CPU 提供了多于两种的操作模式。以下是这几种模式的两种可能用途：</h3><p>虽然大多数系统只区分 <strong>用户模式</strong> 和 <strong>内核模式</strong>，但一些 CPU 支持多种模式。多种模式可用于提供更细粒度的安全策略。例如，除了区分用户模式和内核模式外，还可以区分不同类型的用户模式。也许属于同一组的用户可以执行彼此的代码。当这些用户运行代码时，机器会进入指定的模式。在这种模式下，该组的成员可以运行任何其他成员的代码。<br>另一种可能性是在内核代码内提供不同的区分。例如，特定模式可以允许 USB 设备驱动程序运行。这意味着可以在不切换到内核模式的情况下为 USB 设备提供服务，从而实质上允许 USB 设备驱动程序在类似用户/内核模式下运行。</p>
<h3 id="1-9-定时器可以用来计算当前时间。简要描述如何实现这一点。"><a href="#1-9-定时器可以用来计算当前时间。简要描述如何实现这一点。" class="headerlink" title="1.9. 定时器可以用来计算当前时间。简要描述如何实现这一点。"></a>1.9. 定时器可以用来计算当前时间。简要描述如何实现这一点。</h3><p>程序可以使用以下方法通过定时器中断来计算当前时间。程序可以设置一个未来的定时器并进入睡眠状态。当定时器中断唤醒程序时，它可以更新其本地状态，记录它已接收到的中断次数。然后，它可以继续设置定时器中断，并在实际发生中断时更新本地状态。</p>
<h3 id="1-10-给出两个缓存有用的理由。它们解决了什么问题？它们引发了什么问题？如果缓存可以做得和它所缓存的设备一样大（例如，缓存和磁盘一样大），为什么不把它做得那么大，消除设备？"><a href="#1-10-给出两个缓存有用的理由。它们解决了什么问题？它们引发了什么问题？如果缓存可以做得和它所缓存的设备一样大（例如，缓存和磁盘一样大），为什么不把它做得那么大，消除设备？" class="headerlink" title="1.10. 给出两个缓存有用的理由。它们解决了什么问题？它们引发了什么问题？如果缓存可以做得和它所缓存的设备一样大（例如，缓存和磁盘一样大），为什么不把它做得那么大，消除设备？"></a>1.10. 给出两个缓存有用的理由。它们解决了什么问题？它们引发了什么问题？如果缓存可以做得和它所缓存的设备一样大（例如，缓存和磁盘一样大），为什么不把它做得那么大，消除设备？</h3><p>缓存对于需要交换数据的两个或多个组件很有用，且这些组件以不同的速度进行数据传输。缓存通过在组件之间提供一个中间速度的缓冲区来解决传输问题。如果快设备在缓存中找到了它需要的数据，它就不需要等待慢设备。缓存中的数据必须与组件中的数据保持一致。  </p>
<p>如果组件的数据值发生变化，而该数据也在缓存中，那么缓存也必须更新。这在多处理器系统中尤其成问题，因为可能有多个进程同时访问某个数据。如果缓存的大小与组件相同，那么只有当（a）缓存和组件具有相同的状态保存能力（即，如果组件在断电时保留其数据，缓存也必须保留数据），并且（b）缓存是可承受的，因为更快的存储往往更昂贵时，才可以通过缓存替代组件。</p>
<h3 id="1-11-区分客户端-服务器模型和点对点模型的分布式系统。"><a href="#1-11-区分客户端-服务器模型和点对点模型的分布式系统。" class="headerlink" title="1.11. 区分客户端-服务器模型和点对点模型的分布式系统。"></a>1.11. 区分客户端-服务器模型和点对点模型的分布式系统。</h3><p><strong>客户端-服务器模型</strong>明确区分了客户端和服务器的角色。在这种模型下，客户端请求由服务器提供的服务。<strong>点对点模型</strong>没有那么严格的角色区分。实际上，系统中的所有节点都被视为对等节点，因此可以充当客户端或服务器，甚至同时充当两者。一个节点可以请求来自其他对等节点的服务，或者该节点可能为系统中的其他对等节点提供服务。  </p>
<p>例如，假设我们有一个共享食谱的节点系统。在 <strong>客户端-服务器模型</strong> 下，所有食谱都存储在服务器中。如果客户端希望访问食谱，它必须向指定的服务器请求该食谱。在 <strong>点对点模型</strong> 下，一个对等节点可以向其他对等节点请求指定的食谱。拥有该食谱的节点可以将其提供给请求的节点。请注意，每个对等节点可能同时作为客户端（它可以请求食谱）和服务器（它可以提供食谱）。</p>
<h2 id="2-第2章-操作系统结构"><a href="#2-第2章-操作系统结构" class="headerlink" title="2. 第2章 操作系统结构"></a>2. 第2章 操作系统结构</h2><h3 id="2-1-系统调用的目的是什么？"><a href="#2-1-系统调用的目的是什么？" class="headerlink" title="2.1. 系统调用的目的是什么？"></a>2.1. 系统调用的目的是什么？</h3><p><strong>系统调用</strong>允许用户级进程请求操作系统提供服务。</p>
<h3 id="2-2-命令解释器的目的是什么？为什么它通常与内核分开？"><a href="#2-2-命令解释器的目的是什么？为什么它通常与内核分开？" class="headerlink" title="2.2. 命令解释器的目的是什么？为什么它通常与内核分开？"></a>2.2. 命令解释器的目的是什么？为什么它通常与内核分开？</h3><p>命令解释器从用户或命令文件中读取命令并执行它们，通常通过将它们转换为一个或多个系统调用。它通常不属于内核，因为命令解释器是可能会发生变化的。</p>
<h3 id="2-3-在-UNIX-系统中，命令解释器或-shell-执行哪些系统调用来启动新进程？"><a href="#2-3-在-UNIX-系统中，命令解释器或-shell-执行哪些系统调用来启动新进程？" class="headerlink" title="2.3. 在 UNIX 系统中，命令解释器或 shell 执行哪些系统调用来启动新进程？"></a>2.3. 在 UNIX 系统中，命令解释器或 shell 执行哪些系统调用来启动新进程？</h3><p>启动新进程时需要执行 <strong>fork()</strong> 系统调用和 <strong>exec()</strong> 系统调用。<strong>fork()</strong> 调用会克隆当前正在执行的进程，而 <strong>exec()</strong> 调用会在调用进程上覆盖一个基于不同可执行文件的新进程。</p>
<h3 id="2-4-系统程序的目的是什么？"><a href="#2-4-系统程序的目的是什么？" class="headerlink" title="2.4. 系统程序的目的是什么？"></a>2.4. 系统程序的目的是什么？</h3><p><strong>系统程序</strong>可以看作是有用的系统调用的集合。它们为用户提供基本功能，使得用户不必编写自己的程序来解决常见的问题。</p>
<h3 id="2-5-分层设计方法的主要优点是什么？分层设计方法的缺点是什么？"><a href="#2-5-分层设计方法的主要优点是什么？分层设计方法的缺点是什么？" class="headerlink" title="2.5. 分层设计方法的主要优点是什么？分层设计方法的缺点是什么？"></a>2.5. 分层设计方法的主要优点是什么？分层设计方法的缺点是什么？</h3><p>与所有模块化设计一样，<strong>操作系统的模块化设计</strong>有多个优点。系统更容易调试和修改，因为变更只会影响系统的有限部分，而不是触及所有部分。信息仅保存在需要的地方，并且仅在定义和限制的区域内可访问，因此任何影响该数据的错误都必须限于特定的模块或层。<strong>分层设计方法的主要缺点</strong>是由于需要通过不同的层次来获取操作系统提供的服务，因此性能较差。</p>
<h3 id="2-6-列出操作系统提供的五项服务，并解释每项如何为用户提供便利。在哪些情况下用户级程序无法提供这些服务？请解释你的答案。"><a href="#2-6-列出操作系统提供的五项服务，并解释每项如何为用户提供便利。在哪些情况下用户级程序无法提供这些服务？请解释你的答案。" class="headerlink" title="2.6. 列出操作系统提供的五项服务，并解释每项如何为用户提供便利。在哪些情况下用户级程序无法提供这些服务？请解释你的答案。"></a>2.6. 列出操作系统提供的五项服务，并解释每项如何为用户提供便利。在哪些情况下用户级程序无法提供这些服务？请解释你的答案。</h3><p>五项服务如下：</p>
<ul>
<li><strong>程序执行</strong>：操作系统将文件的内容（或部分）加载到内存并开始执行。用户级程序不能被信任正确地分配 CPU 时间。  </li>
<li><strong>I/O 操作</strong>：需要与磁盘、磁带和其他设备进行低级别的通信。用户只需指定设备和执行的操作，系统会将请求转换为设备或控制器特定的命令。用户级程序不能被信任只访问它们应该访问的设备，并且只能在设备未被其他程序使用时进行访问。  </li>
<li><strong>文件系统操作</strong>：文件创建、删除、分配和命名的许多细节应该由操作系统处理，用户不需要手动完成。磁盘空间块由文件使用并且必须被追踪。删除文件需要移除文件的名称信息并释放已分配的块。保护措施也必须被检查以确保正确的文件访问。用户程序无法确保遵守保护方法，也不能被信任仅分配空闲块并在文件删除时释放块。  </li>
<li><strong>通信</strong>：系统间的消息传递需要将消息转换为信息包，发送到网络控制器，通过通信介质传输，并由目标系统重新组装。包排序和数据修正必须发生。用户程序可能无法协调访问网络设备，或者它们可能接收到其他进程的包。  </li>
<li><strong>错误检测</strong>：错误检测发生在硬件和软件层级。在硬件层，所有数据传输必须检查，以确保数据在传输过程中没有被损坏。所有存储介质上的数据必须检查，以确保它们在写入介质后没有发生变化。在软件层，必须检查存储介质的数据一致性——例如，已分配和未分配的存储块数量是否与设备上的总数匹配。错误通常是进程独立的（例如，磁盘上的数据损坏），因此必须有一个全局程序（操作系统）来处理所有类型的错误。此外，当操作系统处理错误时，进程无需包含代码来捕获和修正系统上的所有错误。</li>
</ul>
<h3 id="2-7-为什么有些系统将操作系统存储在固件中，而其他系统则将其存储在磁盘上？"><a href="#2-7-为什么有些系统将操作系统存储在固件中，而其他系统则将其存储在磁盘上？" class="headerlink" title="2.7. 为什么有些系统将操作系统存储在固件中，而其他系统则将其存储在磁盘上？"></a>2.7. 为什么有些系统将操作系统存储在固件中，而其他系统则将其存储在磁盘上？</h3><ul>
<li>存储在固件中的系统：适用于对启动速度、可靠性和低功耗有严格要求的嵌入式系统、实时系统和一些特殊用途的设备。它们通常具有有限的存储空间，并且要求系统能够在断电后恢复。</li>
<li>存储在磁盘上的系统：适用于需要更高存储容量、灵活性、可定制性和易于更新的系统。它们通常是通用计算平台（如桌面电脑、服务器等），能够支持较大的操作系统和应用程序，且允许频繁升级。</li>
</ul>
<h3 id="2-8-如何设计一个系统，允许从多个操作系统中选择启动？引导程序需要做什么？"><a href="#2-8-如何设计一个系统，允许从多个操作系统中选择启动？引导程序需要做什么？" class="headerlink" title="2.8. 如何设计一个系统，允许从多个操作系统中选择启动？引导程序需要做什么？"></a>2.8. 如何设计一个系统，允许从多个操作系统中选择启动？引导程序需要做什么？</h3><p>考虑一个想要同时运行 <strong>Windows</strong> 和三种不同 <strong>Linux</strong> 发行版（例如 <strong>RedHat</strong>、<strong>Debian</strong> 和 <strong>Ubuntu</strong>）的系统。每个操作系统将存储在磁盘上。在系统启动时，一个特殊的程序（我们称之为引导管理器）将决定启动哪个操作系统。这意味着系统在启动时不会直接启动一个操作系统，而是引导管理器将在系统启动时首先运行。引导管理器负责确定启动哪个系统。通常，引导管理器必须存储在硬盘上的特定位置，以便在系统启动时被识别。引导管理器通常提供供用户选择的操作系统，并且如果用户未选择，通常会默认启动某个操作系统。</p>
<p>设计一个多重引导系统需要通过引导程序（如GRUB或Windows Boot Manager）来管理多个操作系统的启动。引导程序负责扫描系统中的操作系统，提供操作系统选择菜单，并加载相应的操作系统内核。它将控制权交给选定的操作系统，确保用户能够在启动时自由选择操作系统。系统需要适当的硬盘分区，每个操作系统独立分区，并通过引导管理器的配置文件管理启动项，支持快速启动和修复功能，确保系统的可靠性和灵活性。</p>
<hr>
<h2 id="3-第3章-进程"><a href="#3-第3章-进程" class="headerlink" title="3. 第3章 进程"></a>3. 第3章 进程</h2><h3 id="3-1-使用图-3-30-中显示的程序，解释在-LINE-A-处的输出是什么。"><a href="#3-1-使用图-3-30-中显示的程序，解释在-LINE-A-处的输出是什么。" class="headerlink" title="3.1. 使用图 3.30 中显示的程序，解释在 LINE A 处的输出是什么。"></a>3.1. 使用图 3.30 中显示的程序，解释在 <strong>LINE A</strong> 处的输出是什么。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">/* 子进程 */</span> </span><br><span class="line">		value += <span class="number">15</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123; <span class="comment">/* 父进程 */</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;PARENT: value = %d&quot;</span>, value); <span class="comment">/* LINE A */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">在此程序中，**fork()** 创建了一个子进程。子进程将 `value` 增加 <span class="number">15</span> 并退出。父进程等待子进程完成后，打印出 `value`。由于父进程和子进程都有各自独立的内存空间，所以 `value` 在父进程中不会受到子进程修改的影响。因此，**LINE A** 的输出将是 `PARENT: value = <span class="number">5</span>`，因为父进程的 `value` 变量在 `fork()` 后没有被修改。</span><br><span class="line"></span><br><span class="line">### <span class="number">3.2</span>. 包括初始父进程在内，该程序创建了多少个进程？</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 创建一个子进程 */</span></span><br><span class="line">    fork();</span><br><span class="line">    <span class="comment">/* 创建另一个子进程 */</span></span><br><span class="line">    fork();</span><br><span class="line">    <span class="comment">/* 再创建一个子进程 */</span></span><br><span class="line">    <span class="comment">/*对于第二个fork()来说，父进程创建了一个新子进程。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">第一个子进程创建了一个新子进程。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">第二个子进程创建了一个新子进程。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">第三个子进程创建了一个新子进程。*/</span></span><br><span class="line">    fork();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>创建了八个进程</strong>。每次调用 <strong>fork()</strong> 都会创建一个新进程，因此总共会创建 8 个进程（父进程和 7 个子进程）。</p>
<h3 id="3-3-苹果公司早期版本的-iOS-操作系统没有并发处理能力。讨论并发处理为操作系统增加的三大复杂性。"><a href="#3-3-苹果公司早期版本的-iOS-操作系统没有并发处理能力。讨论并发处理为操作系统增加的三大复杂性。" class="headerlink" title="3.3. 苹果公司早期版本的 iOS 操作系统没有并发处理能力。讨论并发处理为操作系统增加的三大复杂性。"></a>3.3. 苹果公司早期版本的 iOS 操作系统没有并发处理能力。讨论并发处理为操作系统增加的三大复杂性。</h3><ol>
<li><strong>同步问题</strong>：多个进程或线程的并发执行可能导致共享资源的竞争，进而产生数据不一致和死锁等问题。</li>
<li><strong>调度问题</strong>：如何合理地调度并发任务，确保公平和效率，同时避免优先级反转等问题。</li>
<li><strong>资源管理问题</strong>：需要管理和分配硬件资源（如 CPU、内存、I/O 设备），同时保证各进程按预期运行。</li>
</ol>
<h3 id="3-4-一些计算机系统提供多个寄存器集。如果新的上下文已经加载到其中一个寄存器集中，发生上下文切换时会怎样？如果新的上下文在内存中，而所有寄存器集都在使用中，会发生什么情况？"><a href="#3-4-一些计算机系统提供多个寄存器集。如果新的上下文已经加载到其中一个寄存器集中，发生上下文切换时会怎样？如果新的上下文在内存中，而所有寄存器集都在使用中，会发生什么情况？" class="headerlink" title="3.4. 一些计算机系统提供多个寄存器集。如果新的上下文已经加载到其中一个寄存器集中，发生上下文切换时会怎样？如果新的上下文在内存中，而所有寄存器集都在使用中，会发生什么情况？"></a>3.4. 一些计算机系统提供多个寄存器集。如果新的上下文已经加载到其中一个寄存器集中，发生上下文切换时会怎样？如果新的上下文在内存中，而所有寄存器集都在使用中，会发生什么情况？</h3><p><strong>CPU 当前寄存器集指针</strong>会更改为指向包含新上下文的寄存器集，这需要的时间非常短。如果上下文在内存中，则必须选择一个寄存器集中的上下文，将其移到内存中，然后从内存中加载新上下文到该寄存器集中。与单一寄存器集的系统相比，这个过程需要稍微更长的时间，具体取决于选择哪个寄存器集作为替换目标。</p>
<h3 id="3-5-当进程使用-fork-操作创建新进程时，以下哪个状态是父进程和子进程共享的？"><a href="#3-5-当进程使用-fork-操作创建新进程时，以下哪个状态是父进程和子进程共享的？" class="headerlink" title="3.5. 当进程使用 fork() 操作创建新进程时，以下哪个状态是父进程和子进程共享的？"></a>3.5. 当进程使用 <strong>fork()</strong> 操作创建新进程时，以下哪个状态是父进程和子进程共享的？</h3><p>a. 栈<br>b. 堆<br>c. 共享内存段</p>
<p>只有 <strong>共享内存段</strong> 在父进程和新创建的子进程之间是共享的。栈和堆会为新创建的进程复制。</p>
<h3 id="3-6-考虑-“恰好一次”（exactly-once）语义与-RPC-机制的关系。如果由于网络问题，发送回客户端的-ACK-消息丢失，实施此语义的算法是否仍然正确执行？描述消息的序列，并讨论“恰好一次”是否仍然得到保持。"><a href="#3-6-考虑-“恰好一次”（exactly-once）语义与-RPC-机制的关系。如果由于网络问题，发送回客户端的-ACK-消息丢失，实施此语义的算法是否仍然正确执行？描述消息的序列，并讨论“恰好一次”是否仍然得到保持。" class="headerlink" title="3.6. 考虑 “恰好一次”（exactly once）语义与 RPC 机制的关系。如果由于网络问题，发送回客户端的 ACK 消息丢失，实施此语义的算法是否仍然正确执行？描述消息的序列，并讨论“恰好一次”是否仍然得到保持。"></a>3.6. 考虑 “恰好一次”（exactly once）语义与 RPC 机制的关系。如果由于网络问题，发送回客户端的 ACK 消息丢失，实施此语义的算法是否仍然正确执行？描述消息的序列，并讨论“恰好一次”是否仍然得到保持。</h3><p>“<strong>恰好一次</strong>”语义确保一个远程过程会被执行<strong>一次且仅一次</strong>。实现该语义的一般算法结合了一个确认（<strong>ACK</strong>）机制和时间戳（或其他增量计数器，用于让服务器区分重复消息）。一般策略是客户端发送 RPC 给服务器，并附带时间戳。客户端还会启动一个超时计时器，等待以下两种情况之一的发生：（1）接收到来自服务器的 ACK，表示远程过程已执行，或（2）超时。如果客户端超时，它会认为服务器未能执行远程过程，因此会再次调用 RPC，发送一个更新后的时间戳。客户端可能不会收到 ACK，原因有两个：（1）原始 RPC 未被服务器接收，或（2）RPC 已正确接收并执行，但 ACK 丢失。在情况（1）中，<strong>ACK</strong> 的使用可以确保服务器最终接收并执行 RPC。在情况（2）中，服务器将收到重复的 RPC，并使用时间戳将其识别为重复，从而避免第二次执行该 RPC。需要注意的是，服务器必须发送第二个 ACK 返回客户端，以告知客户端 RPC 已执行。</p>
<p>在RPC机制中，<strong>“恰好一次”</strong>（exactly once）语义确保请求只处理一次。若由于网络问题，发送给客户端的 <strong>ACK</strong> 消息丢失，客户端可能会重试请求。</p>
<ul>
<li><strong>对于幂等请求</strong>（如查询操作），即使ACK丢失，客户端重试也不会影响系统状态，因为请求处理不受重复影响。</li>
<li><strong>对于非幂等请求</strong>（如创建订单），重试会导致相同操作被执行多次，破坏“恰好一次”语义。</li>
</ul>
<p>为了保持“恰好一次”语义，可以使用 <strong>唯一请求标识符</strong> 或 <strong>事务日志</strong> 来防止重复操作。</p>
<h3 id="3-7-假设一个分布式系统容易受到服务器故障的影响。为了保证执行-RPC-时的-“恰好一次”-语义，需要哪些机制？"><a href="#3-7-假设一个分布式系统容易受到服务器故障的影响。为了保证执行-RPC-时的-“恰好一次”-语义，需要哪些机制？" class="headerlink" title="3.7. 假设一个分布式系统容易受到服务器故障的影响。为了保证执行 RPC 时的 “恰好一次” 语义，需要哪些机制？"></a>3.7. 假设一个分布式系统容易受到服务器故障的影响。为了保证执行 RPC 时的 “恰好一次” 语义，需要哪些机制？</h3><p>服务器应该在稳定存储中（如磁盘日志）跟踪接收到的 RPC 操作的信息，包括它们是否已成功执行以及与这些操作相关的结果。当服务器崩溃并接收到 RPC 消息时，服务器可以检查该 RPC 是否已执行过，从而保证 RPC 执行时的“<strong>恰好一次</strong>”语义。</p>
<h2 id="4-第四章-线程与并发"><a href="#4-第四章-线程与并发" class="headerlink" title="4. 第四章 线程与并发"></a>4. 第四章 线程与并发</h2><h3 id="4-1-提供三个编程示例，其中多线程比单线程解决方案提供更好的性能。"><a href="#4-1-提供三个编程示例，其中多线程比单线程解决方案提供更好的性能。" class="headerlink" title="4.1. 提供三个编程示例，其中多线程比单线程解决方案提供更好的性能。"></a>4.1. 提供三个编程示例，其中多线程比单线程解决方案提供更好的性能。</h3><p>a. 一个为每个请求分配独立线程的 Web 服务器</p>
<p>b. 一个并行化的应用程序，如矩阵乘法，其中矩阵的各个部分可以并行处理</p>
<p>c. 一个交互式 GUI 程序，如调试器，其中一个线程用于监控用户输入，另一个线程表示正在运行的应用程序，第三个线程监控性能</p>
<h3 id="4-2-使用-Amdahl-定律，计算一个具有-60-并行组件的应用程序在-a-两个处理核心和-b-四个处理核心上的加速增益。"><a href="#4-2-使用-Amdahl-定律，计算一个具有-60-并行组件的应用程序在-a-两个处理核心和-b-四个处理核心上的加速增益。" class="headerlink" title="4.2. 使用 Amdahl 定律，计算一个具有 60% 并行组件的应用程序在 (a) 两个处理核心和 (b) 四个处理核心上的加速增益。"></a>4.2. 使用 Amdahl 定律，计算一个具有 60% 并行组件的应用程序在 (a) 两个处理核心和 (b) 四个处理核心上的加速增益。</h3><p>a. 使用两个处理核心时，我们获得的加速是 1.42 倍。</p>
<p>b. 使用四个处理核心时，我们获得的加速是 1.82 倍。</p>
<h3 id="4-3-在-4-1-节中描述的多线程-Web-服务器展示了任务并行性还是数据并行性？"><a href="#4-3-在-4-1-节中描述的多线程-Web-服务器展示了任务并行性还是数据并行性？" class="headerlink" title="4.3. 在 4.1 节中描述的多线程 Web 服务器展示了任务并行性还是数据并行性？"></a>4.3. 在 4.1 节中描述的多线程 Web 服务器展示了任务并行性还是数据并行性？</h3><p>数据并行性。每个线程执行相同的任务，但处理不同的数据。</p>
<h3 id="4-4-用户级线程和内核级线程之间的两个区别是什么？在什么情况下一种类型优于另一种？"><a href="#4-4-用户级线程和内核级线程之间的两个区别是什么？在什么情况下一种类型优于另一种？" class="headerlink" title="4.4. 用户级线程和内核级线程之间的两个区别是什么？在什么情况下一种类型优于另一种？"></a>4.4. 用户级线程和内核级线程之间的两个区别是什么？在什么情况下一种类型优于另一种？</h3><p>a. 用户级线程对内核不可见，而内核级线程则由内核管理。</p>
<p>b. 在使用多对一或多对多模型映射的系统中，用户线程由线程库调度，而内核调度内核线程。</p>
<p>c. 内核线程不需要与进程关联，而每个用户线程都属于一个进程。内核线程通常比用户线程更昂贵，因为它们必须通过内核数据结构进行表示。</p>
<h3 id="4-5-描述内核在进行内核级线程的上下文切换时所采取的操作。"><a href="#4-5-描述内核在进行内核级线程的上下文切换时所采取的操作。" class="headerlink" title="4.5. 描述内核在进行内核级线程的上下文切换时所采取的操作。"></a>4.5. 描述内核在进行内核级线程的上下文切换时所采取的操作。</h3><p>内核级线程的上下文切换通常需要保存被切换出线程的 CPU 寄存器值，并恢复新调度线程的 CPU 寄存器。</p>
<h3 id="4-6-创建线程时使用了哪些资源？它们与创建进程时使用的资源有何不同？"><a href="#4-6-创建线程时使用了哪些资源？它们与创建进程时使用的资源有何不同？" class="headerlink" title="4.6. 创建线程时使用了哪些资源？它们与创建进程时使用的资源有何不同？"></a>4.6. 创建线程时使用了哪些资源？它们与创建进程时使用的资源有何不同？</h3><p>由于线程比进程更小，线程创建通常比进程创建使用更少的资源。创建进程需要分配一个进程控制块（PCB），这是一个相对较大的数据结构。PCB 包括内存映射、打开文件的列表和环境变量。分配和管理内存映射通常是最耗时的操作。创建用户线程或内核线程则涉及分配一个小的数据结构来保存寄存器集、堆栈和优先级。</p>
<h3 id="4-7-假设操作系统使用多对多模型将用户级线程映射到内核，并且映射是通过-LWPs（轻量级进程）进行的。此外，系统允许开发人员为实时系统创建实时线程。是否有必要将实时线程绑定到-LWP？解释。"><a href="#4-7-假设操作系统使用多对多模型将用户级线程映射到内核，并且映射是通过-LWPs（轻量级进程）进行的。此外，系统允许开发人员为实时系统创建实时线程。是否有必要将实时线程绑定到-LWP？解释。" class="headerlink" title="4.7. 假设操作系统使用多对多模型将用户级线程映射到内核，并且映射是通过 LWPs（轻量级进程）进行的。此外，系统允许开发人员为实时系统创建实时线程。是否有必要将实时线程绑定到 LWP？解释。"></a>4.7. 假设操作系统使用多对多模型将用户级线程映射到内核，并且映射是通过 LWPs（轻量级进程）进行的。此外，系统允许开发人员为实时系统创建实时线程。是否有必要将实时线程绑定到 LWP？解释。</h3><p>是的。实时应用程序对时效性要求非常高。如果一个线程被标记为实时线程，但没有绑定到 LWP，线程可能在运行前必须等待附加到 LWP。考虑一种情况，其中一个实时线程正在运行（已附加到 LWP），然后开始阻塞（必须执行 I/O，已被更高优先级的实时线程抢占，等待互斥锁等）。当实时线程被阻塞时，它所附加的 LWP 会被分配给另一个线程。当实时线程再次被调度时，它必须先等待附加到 LWP。通过将 LWP 绑定到实时线程，确保线程在调度后能以最小延迟运行。</p>
<h2 id="6-第六章-同步工具"><a href="#6-第六章-同步工具" class="headerlink" title="6. 第六章 同步工具"></a>6. 第六章 同步工具</h2><h3 id="6-1-在-6-4-节中，我们提到频繁禁用中断可能会影响系统时钟。解释为什么会发生这种情况，以及如何最小化这种影响。"><a href="#6-1-在-6-4-节中，我们提到频繁禁用中断可能会影响系统时钟。解释为什么会发生这种情况，以及如何最小化这种影响。" class="headerlink" title="6.1. 在 6.4 节中，我们提到频繁禁用中断可能会影响系统时钟。解释为什么会发生这种情况，以及如何最小化这种影响。"></a>6.1. 在 6.4 节中，我们提到频繁禁用中断可能会影响系统时钟。解释为什么会发生这种情况，以及如何最小化这种影响。</h3><p>系统时钟在每次时钟中断时更新。如果禁用中断，特别是禁用较长时间，系统时钟可能会容易丢失准确的时间。系统时钟还用于调度。例如，进程的时间量子通常以时钟滴答的数量来表示。在每次时钟中断时，调度程序会检查当前运行的进程的时间量子是否已到期。如果禁用时钟中断，调度程序就无法准确地分配时间量子。可以通过仅在非常短的时间内禁用时钟中断来最小化这种影响。</p>
<h3 id="6-2-什么是忙等待？操作系统中还有哪些类型的等待？忙等待可以完全避免吗？解释你的答案。"><a href="#6-2-什么是忙等待？操作系统中还有哪些类型的等待？忙等待可以完全避免吗？解释你的答案。" class="headerlink" title="6.2. 什么是忙等待？操作系统中还有哪些类型的等待？忙等待可以完全避免吗？解释你的答案。"></a>6.2. 什么是忙等待？操作系统中还有哪些类型的等待？忙等待可以完全避免吗？解释你的答案。</h3><p>忙等待是指一个进程在一个紧密的循环中等待某个条件满足，而不放弃处理器。避免忙等待的一种策略是将等待的进程暂时置为睡眠状态，并在适当的程序状态达到时唤醒它，但这种方法会带来将进程置为睡眠和后续唤醒的开销。</p>
<h3 id="6-3-解释为什么自旋锁不适用于单处理器系统，但在多处理器系统中常被使用。"><a href="#6-3-解释为什么自旋锁不适用于单处理器系统，但在多处理器系统中常被使用。" class="headerlink" title="6.3. 解释为什么自旋锁不适用于单处理器系统，但在多处理器系统中常被使用。"></a>6.3. 解释为什么自旋锁不适用于单处理器系统，但在多处理器系统中常被使用。</h3><p>自旋锁不适用于单处理器系统，因为只有通过执行另一个进程，才能获取释放自旋锁的条件。如果进程不放弃处理器，其他进程就没有机会设置程序条件，使得第一个进程能够继续。在多处理器系统中，其他进程可以在不同的处理器上执行，因此可以修改程序状态，从而释放第一个进程的自旋锁。</p>
<h3 id="6-4-证明如果-wait-和-signal-信号量操作不是原子执行的，那么互斥可能会被破坏。"><a href="#6-4-证明如果-wait-和-signal-信号量操作不是原子执行的，那么互斥可能会被破坏。" class="headerlink" title="6.4. 证明如果 wait() 和 signal() 信号量操作不是原子执行的，那么互斥可能会被破坏。"></a>6.4. 证明如果 <code>wait()</code> 和 <code>signal()</code> 信号量操作不是原子执行的，那么互斥可能会被破坏。</h3><p><code>wait()</code> 操作原子地递减信号量所关联的值。如果在信号量的值为 1 时，两个 <code>wait()</code> 操作分别执行且不是原子执行的，那么两个操作都可能递减信号量的值，从而破坏互斥。</p>
<h3 id="6-5-说明如何使用二进制信号量来实现进程间的互斥。"><a href="#6-5-说明如何使用二进制信号量来实现进程间的互斥。" class="headerlink" title="6.5. 说明如何使用二进制信号量来实现进程间的互斥。"></a>6.5. 说明如何使用二进制信号量来实现进程间的互斥。</h3><p>进程共享一个初始化为 1 的信号量 <code>mutex</code>。每个进程的组织方式如下：</p>
<h3 id="6-6-竞争条件在许多计算机系统中是可能的。考虑一个银行系统，该系统通过两个函数维护账户余额：deposit-amount-和-withdraw-amount-。这两个函数传递要存入或取出的金额。假设丈夫和妻子共同拥有一个银行账户。与此同时，丈夫调用-withdraw-函数，妻子调用-deposit-。描述竞争条件是如何发生的，以及如何防止这种竞争条件发生。"><a href="#6-6-竞争条件在许多计算机系统中是可能的。考虑一个银行系统，该系统通过两个函数维护账户余额：deposit-amount-和-withdraw-amount-。这两个函数传递要存入或取出的金额。假设丈夫和妻子共同拥有一个银行账户。与此同时，丈夫调用-withdraw-函数，妻子调用-deposit-。描述竞争条件是如何发生的，以及如何防止这种竞争条件发生。" class="headerlink" title="6.6. 竞争条件在许多计算机系统中是可能的。考虑一个银行系统，该系统通过两个函数维护账户余额：deposit(amount) 和 withdraw(amount)。这两个函数传递要存入或取出的金额。假设丈夫和妻子共同拥有一个银行账户。与此同时，丈夫调用 withdraw() 函数，妻子调用 deposit()。描述竞争条件是如何发生的，以及如何防止这种竞争条件发生。"></a>6.6. 竞争条件在许多计算机系统中是可能的。考虑一个银行系统，该系统通过两个函数维护账户余额：<code>deposit(amount)</code> 和 <code>withdraw(amount)</code>。这两个函数传递要存入或取出的金额。假设丈夫和妻子共同拥有一个银行账户。与此同时，丈夫调用 <code>withdraw()</code> 函数，妻子调用 <code>deposit()</code>。描述竞争条件是如何发生的，以及如何防止这种竞争条件发生。</h3><p>假设账户余额为 250.00 美元，丈夫调用 <code>withdraw($50)</code>，妻子调用 <code>deposit($100)</code>。显然，正确的余额应为 300.00 美元。由于这两个交易将被序列化，丈夫的本地余额值变为 200.00 美元，但在他提交交易之前，<code>deposit(100)</code> 操作发生并将共享余额更新为 300.00 美元。然后切换回丈夫，共享余额的值被设置为 200.00 美元—显然是一个不正确的值。</p>
<h2 id="7-第七章-同步示例"><a href="#7-第七章-同步示例" class="headerlink" title="7. 第七章 同步示例"></a>7. 第七章 同步示例</h2><h3 id="7-1-解释为什么-Windows-和-Linux-实现了多种锁机制。描述它们在什么情况下使用自旋锁、互斥锁、信号量和条件变量，并解释每种机制的需要。"><a href="#7-1-解释为什么-Windows-和-Linux-实现了多种锁机制。描述它们在什么情况下使用自旋锁、互斥锁、信号量和条件变量，并解释每种机制的需要。" class="headerlink" title="7.1. 解释为什么 Windows 和 Linux 实现了多种锁机制。描述它们在什么情况下使用自旋锁、互斥锁、信号量和条件变量，并解释每种机制的需要。"></a>7.1. 解释为什么 Windows 和 Linux 实现了多种锁机制。描述它们在什么情况下使用自旋锁、互斥锁、信号量和条件变量，并解释每种机制的需要。</h3><p>这些操作系统根据应用程序开发者的需求提供不同的锁机制。自旋锁适用于多处理器系统，在这些系统中，线程可以在忙循环中运行（短时间内）而不是因被放入睡眠队列而带来开销。互斥锁适用于锁定资源。Solaris 2 使用自适应互斥锁，这意味着在多处理器机器上，互斥锁是用自旋锁实现的。信号量和条件变量更适合当一个资源需要长时间持有时的同步，因为长时间自旋是低效的。</p>
<h3 id="7-2-Windows-提供了一种轻量级同步工具，称为简化的读写锁（slim-reader-writer-locks）。而大多数读写锁实现倾向于优先考虑读者或写者，或者可能使用-FIFO-策略排序等待线程，简化的读写锁既不偏向读者也不偏向写者，等待线程也不会按-FIFO-队列排序。解释提供这种同步工具的好处。"><a href="#7-2-Windows-提供了一种轻量级同步工具，称为简化的读写锁（slim-reader-writer-locks）。而大多数读写锁实现倾向于优先考虑读者或写者，或者可能使用-FIFO-策略排序等待线程，简化的读写锁既不偏向读者也不偏向写者，等待线程也不会按-FIFO-队列排序。解释提供这种同步工具的好处。" class="headerlink" title="7.2. Windows 提供了一种轻量级同步工具，称为简化的读写锁（slim reader-writer locks）。而大多数读写锁实现倾向于优先考虑读者或写者，或者可能使用 FIFO 策略排序等待线程，简化的读写锁既不偏向读者也不偏向写者，等待线程也不会按 FIFO 队列排序。解释提供这种同步工具的好处。"></a>7.2. Windows 提供了一种轻量级同步工具，称为简化的读写锁（slim reader-writer locks）。而大多数读写锁实现倾向于优先考虑读者或写者，或者可能使用 FIFO 策略排序等待线程，简化的读写锁既不偏向读者也不偏向写者，等待线程也不会按 FIFO 队列排序。解释提供这种同步工具的好处。</h3><p>简化性。如果读写锁提供公平性或者偏向读者或写者，它们会涉及更多的开销。提供这样一个简单的同步机制使得获取锁的操作更快速。使用此锁可能最适用于需要读写锁的情况，但同样重要的是迅速获取和释放它们。</p>
<h3 id="7-3-描述如果将二进制信号量替换为互斥锁，生产者和消费者进程在图-7-1-和图-7-2-中需要进行哪些更改。"><a href="#7-3-描述如果将二进制信号量替换为互斥锁，生产者和消费者进程在图-7-1-和图-7-2-中需要进行哪些更改。" class="headerlink" title="7.3. 描述如果将二进制信号量替换为互斥锁，生产者和消费者进程在图 7.1 和图 7.2 中需要进行哪些更改。"></a>7.3. 描述如果将二进制信号量替换为互斥锁，生产者和消费者进程在图 7.1 和图 7.2 中需要进行哪些更改。</h3><p>需要将对 <code>wait(mutex)</code> 和 <code>signal(mutex)</code> 的调用替换为互斥锁的 API 调用，例如 <code>acquire(mutex)</code> 和 <code>release(mutex)</code>。</p>
<h3 id="7-4-描述在哲学家就餐问题中死锁是如何发生的。"><a href="#7-4-描述在哲学家就餐问题中死锁是如何发生的。" class="headerlink" title="7.4. 描述在哲学家就餐问题中死锁是如何发生的。"></a>7.4. 描述在哲学家就餐问题中死锁是如何发生的。</h3><p>如果所有哲学家同时拿起他们的左叉，当他们转身去拿右叉时，会发现它不可用，并在等待右叉变得可用时阻塞。这个等待资源变得可用的阻塞就是死锁的情况。</p>
<h3 id="7-5-解释-Windows-调度程序对象中的信号状态和非信号状态之间的区别。"><a href="#7-5-解释-Windows-调度程序对象中的信号状态和非信号状态之间的区别。" class="headerlink" title="7.5. 解释 Windows 调度程序对象中的信号状态和非信号状态之间的区别。"></a>7.5. 解释 Windows 调度程序对象中的信号状态和非信号状态之间的区别。</h3><p>一个处于信号状态的对象是可用的，线程在尝试获取它时不会阻塞。当锁被获取时，它处于非信号状态。当锁被释放时，它会过渡到信号状态。</p>
<h3 id="7-6-假设-val-是-Linux-系统中的一个原子整数。以下操作完成后-val-的值是多少？"><a href="#7-6-假设-val-是-Linux-系统中的一个原子整数。以下操作完成后-val-的值是多少？" class="headerlink" title="7.6. 假设 val 是 Linux 系统中的一个原子整数。以下操作完成后 val 的值是多少？"></a>7.6. 假设 <code>val</code> 是 Linux 系统中的一个原子整数。以下操作完成后 <code>val</code> 的值是多少？</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">atomic set(&amp;val, 10);</span><br><span class="line">atomic sub(8, &amp;val);</span><br><span class="line">atomic inc(&amp;val);</span><br><span class="line">atomic inc(&amp;val);</span><br><span class="line">atomic add(6, &amp;val);</span><br><span class="line">atomic sub(3, &amp;val);</span><br></pre></td></tr></table></figure>
<p><code>val</code> 的最终值是：<br><code>10 - 8 + 1 + 1 + 6 - 3 = 7</code></p>
<h2 id="9-第9章-主内存"><a href="#9-第9章-主内存" class="headerlink" title="9. 第9章 主内存"></a>9. 第9章 主内存</h2><h3 id="9-1-说明逻辑地址和物理地址之间的两个区别"><a href="#9-1-说明逻辑地址和物理地址之间的两个区别" class="headerlink" title="9.1. 说明逻辑地址和物理地址之间的两个区别"></a>9.1. 说明逻辑地址和物理地址之间的两个区别</h3><p><strong>逻辑地址</strong>并不指代实际的物理地址；它是一个抽象地址，位于抽象地址空间中。<strong>物理地址</strong>指代内存中的实际物理地址。<strong>逻辑地址</strong>由 <strong>CPU</strong> 生成，并由内存管理单元（MMU）翻译成物理地址。因此，物理地址是由 <strong>MMU</strong> 生成的。</p>
<h3 id="9-2-为什么页面大小总是2的幂？"><a href="#9-2-为什么页面大小总是2的幂？" class="headerlink" title="9.2. 为什么页面大小总是2的幂？"></a>9.2. 为什么页面大小总是2的幂？</h3><p>回想一下分页是通过将地址分解为页面和偏移量来实现的。最有效的方法是将地址分解为 X 位页面和 Y 位偏移，而不是对地址进行算术运算来计算页面号和偏移量。因为每个位表示一个2的幂，所以在位之间分割地址会导致页面大小为2的幂。</p>
<h3 id="9-3-考虑一个可以将程序分为两部分：代码和数据。CPU-知道它需要指令（指令获取）还是数据（数据获取或存储）。因此，提供了两对基址-限址寄存器：一个用于指令，一个用于数据。指令基址-限址寄存器对是自动只读的，因此程序可以在不同用户之间共享。讨论这种方案的优缺点。"><a href="#9-3-考虑一个可以将程序分为两部分：代码和数据。CPU-知道它需要指令（指令获取）还是数据（数据获取或存储）。因此，提供了两对基址-限址寄存器：一个用于指令，一个用于数据。指令基址-限址寄存器对是自动只读的，因此程序可以在不同用户之间共享。讨论这种方案的优缺点。" class="headerlink" title="9.3. 考虑一个可以将程序分为两部分：代码和数据。CPU 知道它需要指令（指令获取）还是数据（数据获取或存储）。因此，提供了两对基址-限址寄存器：一个用于指令，一个用于数据。指令基址-限址寄存器对是自动只读的，因此程序可以在不同用户之间共享。讨论这种方案的优缺点。"></a>9.3. 考虑一个可以将程序分为两部分：代码和数据。CPU 知道它需要指令（指令获取）还是数据（数据获取或存储）。因此，提供了两对基址-限址寄存器：一个用于指令，一个用于数据。指令基址-限址寄存器对是自动只读的，因此程序可以在不同用户之间共享。讨论这种方案的优缺点。</h3><p>该方案的主要优点是它是一个有效的代码和数据共享机制。例如，只需要将编辑器或编译器的一份副本保留在内存中，所有需要访问编辑器或编译器代码的进程都可以共享这份代码。另一个优点是对代码的保护，避免错误修改。唯一的缺点是代码和数据必须分开，这通常在编译器生成的代码中遵守。</p>
<h3 id="9-4-考虑一个逻辑地址空间，包含64个页面，每个页面包含1024个字，映射到一个包含32个框架的物理内存中。"><a href="#9-4-考虑一个逻辑地址空间，包含64个页面，每个页面包含1024个字，映射到一个包含32个框架的物理内存中。" class="headerlink" title="9.4. 考虑一个逻辑地址空间，包含64个页面，每个页面包含1024个字，映射到一个包含32个框架的物理内存中。"></a>9.4. 考虑一个逻辑地址空间，包含64个页面，每个页面包含1024个字，映射到一个包含32个框架的物理内存中。</h3><p><strong>a.</strong> 逻辑地址有多少位？<br><strong>b.</strong> 物理地址有多少位？</p>
<p><strong>a.</strong> 逻辑地址：16位<br><strong>b.</strong> 物理地址：15位</p>
<h3 id="9-5-允许页表中的两个条目指向内存中的同一页面框架会有什么影响？解释如何使用这种影响来减少将大量内存从一个地方复制到另一个地方所需的时间。更新一个页面上的某个字节会对另一个页面产生什么影响？"><a href="#9-5-允许页表中的两个条目指向内存中的同一页面框架会有什么影响？解释如何使用这种影响来减少将大量内存从一个地方复制到另一个地方所需的时间。更新一个页面上的某个字节会对另一个页面产生什么影响？" class="headerlink" title="9.5. 允许页表中的两个条目指向内存中的同一页面框架会有什么影响？解释如何使用这种影响来减少将大量内存从一个地方复制到另一个地方所需的时间。更新一个页面上的某个字节会对另一个页面产生什么影响？"></a>9.5. 允许页表中的两个条目指向内存中的同一页面框架会有什么影响？解释如何使用这种影响来减少将大量内存从一个地方复制到另一个地方所需的时间。更新一个页面上的某个字节会对另一个页面产生什么影响？</h3><p>通过允许页表中的两个条目指向内存中的同一页面框架，用户可以共享代码和数据。如果代码是可重入的，通过共享大型程序（如文本编辑器、编译器和数据库系统）可以节省大量内存空间。通过让不同的页表指向相同的内存位置，可以实现“复制”大量内存。然而，共享非重入的代码或数据意味着任何有访问代码的用户都可以修改它，这些修改会反映在其他用户的“副本”中。</p>
<h3 id="9-6-给定六个内存分区，大小分别为300KB、600KB、350KB、200KB、750KB和125KB（按顺序），如何通过-首次适应法、最佳适应法和最差适应法来放置以下大小的进程：115KB、500KB、358KB、200KB和375KB（按顺序）？"><a href="#9-6-给定六个内存分区，大小分别为300KB、600KB、350KB、200KB、750KB和125KB（按顺序），如何通过-首次适应法、最佳适应法和最差适应法来放置以下大小的进程：115KB、500KB、358KB、200KB和375KB（按顺序）？" class="headerlink" title="9.6. 给定六个内存分区，大小分别为300KB、600KB、350KB、200KB、750KB和125KB（按顺序），如何通过 首次适应法、最佳适应法和最差适应法来放置以下大小的进程：115KB、500KB、358KB、200KB和375KB（按顺序）？"></a>9.6. 给定六个内存分区，大小分别为300KB、600KB、350KB、200KB、750KB和125KB（按顺序），如何通过 <strong>首次适应法</strong>、<strong>最佳适应法</strong>和<strong>最差适应法</strong>来放置以下大小的进程：115KB、500KB、358KB、200KB和375KB（按顺序）？</h3><p><strong>a. 首次适应法：</strong>  </p>
<ul>
<li>115KB 放入 300KB 分区，剩下 185KB, 600KB, 350KB, 200KB, 750KB, 125KB  </li>
<li>500KB 放入 600KB 分区，剩下 185KB, 100KB, 350KB, 200KB, 750KB, 125KB  </li>
<li>358KB 放入 750KB 分区，剩下 185KB, 100KB, 350KB, 200KB, 392KB, 125KB  </li>
<li>200KB 放入 350KB 分区，剩下 185KB, 100KB, 150KB, 200KB, 392KB, 125KB  </li>
<li>375KB 放入 392KB 分区，剩下 185KB, 100KB, 150KB, 200KB, 17KB, 125KB  </li>
</ul>
<p><strong>b. 最佳适应法：</strong>  </p>
<ul>
<li>115KB 放入 125KB 分区，剩下 300KB, 600KB, 350KB, 200KB, 750KB, 10KB  </li>
<li>500KB 放入 600KB 分区，剩下 300KB, 100KB, 350KB, 200KB, 750KB, 10KB  </li>
<li>358KB 放入 750KB 分区，剩下 300KB, 100KB, 350KB, 200KB, 392KB, 10KB  </li>
<li>200KB 放入 200KB 分区，剩下 300KB, 100KB, 350KB, 0KB, 392KB, 10KB  </li>
<li>375KB 放入 392KB 分区，剩下 300KB, 100KB, 350KB, 0KB, 17KB, 10KB  </li>
</ul>
<p><strong>c. 最差适应法：</strong>  </p>
<ul>
<li>115KB 放入 750KB 分区，剩下 300KB, 600KB, 350KB, 200KB, 635KB, 125KB  </li>
<li>500KB 放入 635KB 分区，剩下 300KB, 600KB, 350KB, 200KB, 135KB, 125KB  </li>
<li>358KB 放入 600KB 分区，剩下 300KB, 242KB, 350KB, 200KB, 135KB, 125KB  </li>
<li>200KB 放入 350KB 分区，剩下 300KB, 242KB, 150KB, 200KB, 135KB, 125KB  </li>
<li>375KB 必须等待</li>
</ul>
<h3 id="9-7-假设页大小为1KB，以下地址引用（以十进制给出）的页号和偏移量是多少："><a href="#9-7-假设页大小为1KB，以下地址引用（以十进制给出）的页号和偏移量是多少：" class="headerlink" title="9.7. 假设页大小为1KB，以下地址引用（以十进制给出）的页号和偏移量是多少："></a>9.7. 假设页大小为1KB，以下地址引用（以十进制给出）的页号和偏移量是多少：</h3><p><strong>a.</strong> 3085<br><strong>b.</strong> 42095<br><strong>c.</strong> 215201<br><strong>d.</strong> 650000<br><strong>e.</strong> 2000001  </p>
<p><strong>a.</strong> 页号 = 3；偏移量 = 13<br><strong>b.</strong> 页号 = 41；偏移量 = 111<br><strong>c.</strong> 页号 = 210；偏移量 = 161<br><strong>d.</strong> 页号 = 634；偏移量 = 784<br><strong>e.</strong> 页号 = 1953；偏移量 = 129</p>
<h2 id="11-第11章-大容量存储结构"><a href="#11-第11章-大容量存储结构" class="headerlink" title="11. 第11章 大容量存储结构"></a>11. 第11章 大容量存储结构</h2><h3 id="11-1-除了-FCFS-调度，磁盘调度在单用户环境中是否有用？解释你的答案。"><a href="#11-1-除了-FCFS-调度，磁盘调度在单用户环境中是否有用？解释你的答案。" class="headerlink" title="11.1. 除了 FCFS 调度，磁盘调度在单用户环境中是否有用？解释你的答案。"></a>11.1. 除了 FCFS 调度，磁盘调度在单用户环境中是否有用？解释你的答案。</h3><p>在单用户环境中，I/O 队列通常是空的。请求通常来自单个进程，涉及一个块或一系列连续的块。在这些情况下，<strong>FCFS</strong> 是一种经济的磁盘调度方法。但 <strong>LOOK</strong> 几乎与之同样容易编程，并且当多个进程执行并发 I/O 时（例如，当一个网页浏览器在后台获取数据，而操作系统正在进行分页，并且另一个应用程序在前台活跃时），它能提供更好的性能。</p>
<h3 id="11-2-解释为什么-SSTF-调度-倾向于优先考虑中间的磁道，而不是最内层和最外层的磁道。"><a href="#11-2-解释为什么-SSTF-调度-倾向于优先考虑中间的磁道，而不是最内层和最外层的磁道。" class="headerlink" title="11.2. 解释为什么 SSTF 调度 倾向于优先考虑中间的磁道，而不是最内层和最外层的磁道。"></a>11.2. 解释为什么 <strong>SSTF 调度</strong> 倾向于优先考虑中间的磁道，而不是最内层和最外层的磁道。</h3><p>磁盘的中心是距离所有其他磁道的平均距离最小的位置。因此，磁头倾向于远离磁盘的边缘。换句话说，当前磁头的位置将磁道分为两组。如果磁头不在磁盘的中心且有新请求到达，新的请求更可能位于包含磁盘中心的组中；因此，磁头更可能朝该方向移动。</p>
<h3 id="11-3-为什么旋转延迟通常不考虑在磁盘调度中？如果要优化延迟，如何修改-SSTF、SCAN-和-C-SCAN-调度？"><a href="#11-3-为什么旋转延迟通常不考虑在磁盘调度中？如果要优化延迟，如何修改-SSTF、SCAN-和-C-SCAN-调度？" class="headerlink" title="11.3. 为什么旋转延迟通常不考虑在磁盘调度中？如果要优化延迟，如何修改 SSTF、SCAN 和 C-SCAN 调度？"></a>11.3. 为什么旋转延迟通常不考虑在磁盘调度中？如果要优化延迟，如何修改 <strong>SSTF、SCAN 和 C-SCAN</strong> 调度？</h3><p>大多数磁盘不将其旋转位置的信息导出给主机。即使它们提供，该信息传输到调度器的时间也可能存在不精确性，而调度器消耗的时间也是变化的，因此旋转位置的信息会变得不准确。此外，磁盘请求通常是基于逻辑块编号给出的，而逻辑块与物理位置之间的映射非常复杂。</p>
<h3 id="11-4-为什么在多任务环境中平衡文件系统的-I-O-分配到系统中的磁盘和控制器上很重要？"><a href="#11-4-为什么在多任务环境中平衡文件系统的-I-O-分配到系统中的磁盘和控制器上很重要？" class="headerlink" title="11.4. 为什么在多任务环境中平衡文件系统的 I/O 分配到系统中的磁盘和控制器上很重要？"></a>11.4. 为什么在多任务环境中平衡文件系统的 I/O 分配到系统中的磁盘和控制器上很重要？</h3><p>一个系统的性能只能达到其最慢瓶颈的速度。磁盘或磁盘控制器通常是现代系统中的瓶颈，因为它们的单独性能无法跟上 CPU 和系统总线的速度。当 I/O 在磁盘和控制器之间平衡时，既不会使单个磁盘或控制器过载，从而避免了瓶颈。</p>
<h3 id="11-5-重新读取代码页从文件系统中与使用交换空间存储它们之间有什么权衡？"><a href="#11-5-重新读取代码页从文件系统中与使用交换空间存储它们之间有什么权衡？" class="headerlink" title="11.5. 重新读取代码页从文件系统中与使用交换空间存储它们之间有什么权衡？"></a>11.5. 重新读取代码页从文件系统中与使用交换空间存储它们之间有什么权衡？</h3><p>如果代码页存储在交换空间中，它们可以更快地传输到主内存中（因为交换空间的分配针对比一般文件系统分配更高效）。使用交换空间如果在进程启动时将页复制到交换空间而不是按需分页到交换空间，可能需要启动时间。如果既用于代码页又用于数据页，还需要分配更多的交换空间。</p>
<h3 id="11-6-是否有方法实现真正的稳定存储？解释你的答案。"><a href="#11-6-是否有方法实现真正的稳定存储？解释你的答案。" class="headerlink" title="11.6. 是否有方法实现真正的稳定存储？解释你的答案。"></a>11.6. 是否有方法实现真正的稳定存储？解释你的答案。</h3><p>真正的稳定存储永远不会丢失数据。稳定存储的基本技术是保持数据的多个副本，以便如果一个副本被销毁，其他副本仍然可以使用。但对于任何方案，我们都可以想象一个足够大的灾难，使得所有副本都被销毁。</p>
<h3 id="11-7-有时说磁带是顺序访问介质，而硬盘是随机访问介质。事实上，存储设备是否适用于随机访问取决于传输大小。流式传输速率是指正在进行的数据传输速率，不包括访问延迟的影响。与此相对，有效传输速率-是总字节数与总秒数的比率，包括诸如访问延迟等开销时间。"><a href="#11-7-有时说磁带是顺序访问介质，而硬盘是随机访问介质。事实上，存储设备是否适用于随机访问取决于传输大小。流式传输速率是指正在进行的数据传输速率，不包括访问延迟的影响。与此相对，有效传输速率-是总字节数与总秒数的比率，包括诸如访问延迟等开销时间。" class="headerlink" title="11.7. 有时说磁带是顺序访问介质，而硬盘是随机访问介质。事实上，存储设备是否适用于随机访问取决于传输大小。流式传输速率是指正在进行的数据传输速率，不包括访问延迟的影响。与此相对，有效传输速率 是总字节数与总秒数的比率，包括诸如访问延迟等开销时间。"></a>11.7. 有时说磁带是顺序访问介质，而硬盘是随机访问介质。事实上，存储设备是否适用于随机访问取决于传输大小。流式传输速率是指正在进行的数据传输速率，不包括访问延迟的影响。与此相对，<strong>有效传输速率</strong> 是总字节数与总秒数的比率，包括诸如访问延迟等开销时间。</h3><p>假设我们有一台计算机，其特征如下：  </p>
<ul>
<li><strong>二级缓存</strong>的访问延迟为 8 纳秒，流式传输速率为 800 兆字节/秒  </li>
<li><strong>主内存</strong>的访问延迟为 60 纳秒，流式传输速率为 80 兆字节/秒  </li>
<li><strong>硬盘</strong>的访问延迟为 15 毫秒，流式传输速率为 5 兆字节/秒  </li>
<li><strong>磁带驱动器</strong>的访问延迟为 60 秒，流式传输速率为 2 兆字节/秒  </li>
</ul>
<p><strong>a.</strong> 随机访问会导致设备的有效传输速率下降，因为在访问时间内没有数据传输。对于硬盘，如果平均访问后跟随流式传输（1）512字节，（2）8千字节，（3）1兆字节，（4）16兆字节，<strong>有效传输速率</strong>是多少？  </p>
<p><strong>b.</strong> 设备的利用率是有效传输速率与流式传输速率的比率。计算硬盘驱动器在（a）部分给出的四种传输大小下的利用率。  </p>
<p><strong>c.</strong> 假设 25%（或更高）的利用率是可以接受的。根据给出的性能数据，计算硬盘设备给出可接受利用率的最小传输大小。</p>
<p><strong>d.</strong> 完成以下句子：磁盘对于大于字节的传输是随机访问设备，而对于较小的传输是顺序访问设备。  </p>
<p><strong>e.</strong> 计算缓存、内存和磁带给出可接受利用率的最小传输大小。  </p>
<p><strong>f.</strong> 磁带何时是随机访问设备，何时是顺序访问设备？</p>
<p><strong>a.</strong> 对于 512 字节，有效传输速率计算如下：<br>ETR = 传输大小 / 传输时间<br>如果 X 是传输大小，那么传输时间是 ((X / STR) + 延迟)。<br>传输时间是 15 毫秒 + (512 字节 / 5 MB/秒) = 15.0097 毫秒。<br>因此，有效传输速率为 512 字节 / 15.0097 毫秒 = 33.12 KB/秒。<br>对于 8KB = 0.47 MB/秒。<br>对于 1MB = 4.65 MB/秒。<br>对于 16MB = 4.98 MB/秒。</p>
<p><strong>b.</strong> 对于 512 字节的设备利用率 = 33.12 KB/秒 / 5 MB/秒 = 0.0064 = 0.64%<br>对于 8KB = 9.4%。<br>对于 1MB = 93%。<br>对于 16MB = 99.6%。</p>
<p><strong>c.</strong> 计算 .25 = ETR / STR，解算传输大小 X。<br>STR = 5MB，所以 1.25MB/S = ETR。<br>1.25MB/S * ((X / 5) + 0.015) = X。<br>0.25X + 0.01875 = X。<br>X = 0.025MB。</p>
<p><strong>d.</strong> 磁盘对于大于 K 字节（其中 K &gt; 磁盘块大小）的传输是随机访问设备，对于较小的传输是顺序访问设备。</p>
<p><strong>e.</strong> 计算缓存、内存和磁带的最小传输大小，以保证可接受的利用率：  </p>
<ul>
<li>对于缓存：STR = 800MB，ETR = 200，延迟 = 8 * 10^−9。  </li>
<li>对于内存：STR = 80MB，ETR = 20，延迟 = 60 * 10^−9。  </li>
<li>对于磁带：STR = 2MB，ETR = 0.5，延迟 = 60s。  </li>
</ul>
<p><strong>f.</strong> 磁带是顺序访问设备，如果它用于顺序读取磁带内容。如果它用于访问存储在磁带上的各种记录，那么它就是随机访问设备。</p>
<h3 id="11-8-RAID-1-组织是否可以比-RAID-0-组织（无冗余条带数据）在读取请求时提供更好的性能？如果是，如何实现？"><a href="#11-8-RAID-1-组织是否可以比-RAID-0-组织（无冗余条带数据）在读取请求时提供更好的性能？如果是，如何实现？" class="headerlink" title="11.8. RAID 1 组织是否可以比 RAID 0 组织（无冗余条带数据）在读取请求时提供更好的性能？如果是，如何实现？"></a>11.8. <strong>RAID 1 组织</strong>是否可以比 <strong>RAID 0 组织</strong>（无冗余条带数据）在读取请求时提供更好的性能？如果是，如何实现？</h3><p>是的，<strong>RAID 1 组织</strong>在读取请求时可以提供更好的性能。当执行读取操作时，<strong>RAID 1 系统</strong>可以决定访问两个副本中的哪个块来满足请求。它可以基于磁头的当前位置来做出选择，因此可以通过选择离目标数据更近的磁头来优化性能。</p>
<h3 id="11-9-给出使用-HDD-作为二级存储的三个理由。"><a href="#11-9-给出使用-HDD-作为二级存储的三个理由。" class="headerlink" title="11.9. 给出使用 HDD 作为二级存储的三个理由。"></a>11.9. 给出使用 HDD 作为二级存储的三个理由。</h3><p>HDD 仍然是最常见的二级存储设备。  </p>
<ul>
<li><strong>a.</strong> 它们是最便宜的随机访问存储设备，提供 TB 级存储，且价格低廉。  </li>
<li><strong>b.</strong> 从外部机箱到存储阵列，许多设备都设计为使用 HDD，提供多种使用 HDD 的方式。  </li>
<li><strong>c.</strong> 与 NVM 存储设备不同，HDD 在整个生命周期中保持相同的读写性能，而 NVM 存储设备会随着填满和老化而失去写入性能。</li>
</ul>
<h3 id="11-10-给出使用-NVM-设备作为二级存储的三个理由。"><a href="#11-10-给出使用-NVM-设备作为二级存储的三个理由。" class="headerlink" title="11.10. 给出使用 NVM 设备作为二级存储的三个理由。"></a>11.10. 给出使用 NVM 设备作为二级存储的三个理由。</h3><p>NVM 设备的容量增加速度和价格下降速度快于 HDD。  </p>
<ul>
<li><strong>a.</strong> 高速 NVM 设备（包括 SSD，通常不包括 USB 驱动器）比 HDD 快得多。二级存储速度对整体系统性能有很大影响。  </li>
<li><strong>b.</strong> NVM 设备比 HDD 使用更少的电力，非常适合笔记本电脑和其他便携式电池驱动设备。NVM 设备也可以比 HDD 小得多，因此可以像智能手机等设备一样直接表面安装到主板上。  </li>
<li><strong>c.</strong> 由于 NVM 设备没有活动部件，它们通常比 HDD 更可靠。</li>
</ul>
<h2 id="12-第12章-I-O系统"><a href="#12-第12章-I-O系统" class="headerlink" title="12. 第12章 I/O系统"></a>12. 第12章 I/O系统</h2><h3 id="12-1-将功能放在设备控制器中而非内核中的三个优点和三个缺点是什么？"><a href="#12-1-将功能放在设备控制器中而非内核中的三个优点和三个缺点是什么？" class="headerlink" title="12.1. 将功能放在设备控制器中而非内核中的三个优点和三个缺点是什么？"></a>12.1. 将功能放在设备控制器中而非内核中的三个优点和三个缺点是什么？</h3><p><strong>三个优点：</strong>  </p>
<ul>
<li><strong>a.</strong> 错误不太可能导致操作系统崩溃。  </li>
<li><strong>b.</strong> 通过利用专用硬件和硬编码算法，可以提高性能。  </li>
<li><strong>c.</strong> 将算法移出内核，可以简化内核。  </li>
</ul>
<p><strong>三个缺点：</strong>  </p>
<ul>
<li><strong>a.</strong> 错误更难修复——需要新的固件版本或新的硬件。  </li>
<li><strong>b.</strong> 改进算法需要硬件更新，而不仅仅是内核或设备驱动程序更新。  </li>
<li><strong>c.</strong> 嵌入式算法可能与应用程序使用设备时发生冲突，导致性能下降。  </li>
</ul>
<h3 id="12-2-第12-2节中手摇信号的例子使用了两个位：一个忙碌位和一个命令就绪位。是否可以只用一个位来实现这个握手？如果可以，请描述协议。如果不行，请解释为什么一个位是不够的。"><a href="#12-2-第12-2节中手摇信号的例子使用了两个位：一个忙碌位和一个命令就绪位。是否可以只用一个位来实现这个握手？如果可以，请描述协议。如果不行，请解释为什么一个位是不够的。" class="headerlink" title="12.2. 第12.2节中手摇信号的例子使用了两个位：一个忙碌位和一个命令就绪位。是否可以只用一个位来实现这个握手？如果可以，请描述协议。如果不行，请解释为什么一个位是不够的。"></a>12.2. 第12.2节中手摇信号的例子使用了两个位：一个忙碌位和一个命令就绪位。是否可以只用一个位来实现这个握手？如果可以，请描述协议。如果不行，请解释为什么一个位是不够的。</h3><p><strong>可以</strong>，使用以下算法。假设我们只使用忙碌位（或命令就绪位，答案相同）。当该位为关时，控制器处于空闲状态。主机写入数据并设置该位，表示操作就绪（相当于设置命令就绪位）。当控制器完成时，它清除忙碌位。然后主机发起下一个操作。  </p>
<p>该解决方案要求主机和控制器都可以读写相同的位，这可能会使电路变得复杂，增加控制器的成本。  </p>
<h3 id="12-3-为什么一个系统可能会使用中断驱动I-O来管理单个串口，而使用轮询I-O来管理前端处理器（如终端集线器）？"><a href="#12-3-为什么一个系统可能会使用中断驱动I-O来管理单个串口，而使用轮询I-O来管理前端处理器（如终端集线器）？" class="headerlink" title="12.3. 为什么一个系统可能会使用中断驱动I/O来管理单个串口，而使用轮询I/O来管理前端处理器（如终端集线器）？"></a>12.3. 为什么一个系统可能会使用中断驱动I/O来管理单个串口，而使用轮询I/O来管理前端处理器（如终端集线器）？</h3><p><strong>轮询比中断驱动I/O更有效</strong>。在I/O操作频繁且持续时间短时，轮询通常更高效。虽然单个串口的I/O相对较少，因此应该使用中断，但终端集线器中的多个串口可能会产生大量短暂的I/O操作，如果为每个操作都中断，可能会对系统产生很大的负担。一个定时良好的轮询循环可以减轻负担，而不会浪费许多资源，因为没有需要I/O时也在循环。  </p>
<h3 id="12-4-如果处理器在I-O完成之前多次迭代繁忙等待循环，轮询I-O完成会浪费大量CPU周期。但是如果I-O设备已准备好服务，轮询可能比捕捉和分派中断更高效。描述一种混合策略，结合轮询、睡眠和中断来处理I-O设备服务。对于这三种策略（纯轮询、纯中断、混合策略），描述一种在这种策略比其他两种更高效的计算环境。"><a href="#12-4-如果处理器在I-O完成之前多次迭代繁忙等待循环，轮询I-O完成会浪费大量CPU周期。但是如果I-O设备已准备好服务，轮询可能比捕捉和分派中断更高效。描述一种混合策略，结合轮询、睡眠和中断来处理I-O设备服务。对于这三种策略（纯轮询、纯中断、混合策略），描述一种在这种策略比其他两种更高效的计算环境。" class="headerlink" title="12.4. 如果处理器在I/O完成之前多次迭代繁忙等待循环，轮询I/O完成会浪费大量CPU周期。但是如果I/O设备已准备好服务，轮询可能比捕捉和分派中断更高效。描述一种混合策略，结合轮询、睡眠和中断来处理I/O设备服务。对于这三种策略（纯轮询、纯中断、混合策略），描述一种在这种策略比其他两种更高效的计算环境。"></a>12.4. 如果处理器在I/O完成之前多次迭代繁忙等待循环，轮询I/O完成会浪费大量CPU周期。但是如果I/O设备已准备好服务，轮询可能比捕捉和分派中断更高效。描述一种混合策略，结合轮询、睡眠和中断来处理I/O设备服务。对于这三种策略（纯轮询、纯中断、混合策略），描述一种在这种策略比其他两种更高效的计算环境。</h3><p><strong>混合策略</strong>可以根据I/O操作等待的时长在轮询和中断之间切换。例如，我们可以进行N次轮询，如果设备在第N+1次时仍然繁忙，则可以设置一个中断并进入睡眠状态。该方法可以避免长时间的繁忙等待周期，适用于非常长或非常短的繁忙时间。如果I/O在N+T时完成（其中T是少量的周期），则由于轮询和设置中断的开销，该方法将变得低效。<strong>纯轮询在等待时间非常短时最有效，而中断在已知长时间等待时最有效。</strong>  </p>
<h3 id="12-5-DMA如何提高系统并发性？它如何使硬件设计变得复杂？"><a href="#12-5-DMA如何提高系统并发性？它如何使硬件设计变得复杂？" class="headerlink" title="12.5. DMA如何提高系统并发性？它如何使硬件设计变得复杂？"></a>12.5. DMA如何提高系统并发性？它如何使硬件设计变得复杂？</h3><p><strong>DMA通过允许CPU在DMA系统通过系统和内存总线传输数据时执行任务，来提高系统并发性。</strong> 硬件设计变得复杂，因为DMA控制器必须集成到系统中，并且系统必须允许DMA控制器成为总线主设备。可能还需要循环窃取，以允许CPU和DMA控制器共享内存总线的使用。  </p>
<h3 id="12-6-为什么随着CPU速度的提高，系统总线和设备速度也需要提升？"><a href="#12-6-为什么随着CPU速度的提高，系统总线和设备速度也需要提升？" class="headerlink" title="12.6. 为什么随着CPU速度的提高，系统总线和设备速度也需要提升？"></a>12.6. 为什么随着CPU速度的提高，系统总线和设备速度也需要提升？</h3><p>考虑一个执行50% I/O和50%计算的系统。如果该系统的CPU性能加倍，系统的整体性能只会提高50%。而如果系统的两个方面都加倍，性能将提高100%。通常，重要的是消除当前系统的瓶颈，并提高整体系统性能，而不是盲目提高单个系统组件的性能。  </p>
<h3 id="12-7-在STREAMS操作中，驱动程序端和流模块的区别是什么？"><a href="#12-7-在STREAMS操作中，驱动程序端和流模块的区别是什么？" class="headerlink" title="12.7. 在STREAMS操作中，驱动程序端和流模块的区别是什么？"></a>12.7. 在STREAMS操作中，驱动程序端和流模块的区别是什么？</h3><p><strong>驱动程序端控制一个物理设备</strong>，该设备可能参与STREAMS操作。<strong>流模块则修改数据流在流头（用户界面）和驱动程序之间的传输。</strong></p>
<h2 id="13-第13章-文件系统接口"><a href="#13-第13章-文件系统接口" class="headerlink" title="13. 第13章 文件系统接口"></a>13. 第13章 文件系统接口</h2><h3 id="13-1-一些系统在用户注销或作业终止时自动删除所有用户文件，除非用户明确要求保留它们。其他系统则保留所有文件，除非用户明确删除它们。讨论这两种方法的相对优缺点。"><a href="#13-1-一些系统在用户注销或作业终止时自动删除所有用户文件，除非用户明确要求保留它们。其他系统则保留所有文件，除非用户明确删除它们。讨论这两种方法的相对优缺点。" class="headerlink" title="13.1. 一些系统在用户注销或作业终止时自动删除所有用户文件，除非用户明确要求保留它们。其他系统则保留所有文件，除非用户明确删除它们。讨论这两种方法的相对优缺点。"></a>13.1. 一些系统在用户注销或作业终止时自动删除所有用户文件，除非用户明确要求保留它们。其他系统则保留所有文件，除非用户明确删除它们。讨论这两种方法的相对优缺点。</h3><p><strong>删除所有未明确保存的文件的优点</strong>是通过不保存不需要或不必要的文件，<strong>可以最小化每个用户所需的文件空间</strong>。<br><strong>保留所有文件，除非用户明确删除的优点</strong>是对用户来说更安全，<strong>用户不会因忘记保存而不小心丢失文件</strong>。</p>
<h3 id="13-2-为什么有些系统会跟踪文件的类型，而其他系统则将其留给用户，或者根本不实现多种文件类型？哪个系统更“好”？"><a href="#13-2-为什么有些系统会跟踪文件的类型，而其他系统则将其留给用户，或者根本不实现多种文件类型？哪个系统更“好”？" class="headerlink" title="13.2. 为什么有些系统会跟踪文件的类型，而其他系统则将其留给用户，或者根本不实现多种文件类型？哪个系统更“好”？"></a>13.2. 为什么有些系统会跟踪文件的类型，而其他系统则将其留给用户，或者根本不实现多种文件类型？哪个系统更“好”？</h3><p><strong>一些系统</strong>允许根据文件类型执行不同的文件操作（例如，ASCII文件可以作为流读取，而数据库文件可以通过索引读取）。其他系统将文件数据的解释留给进程，不提供访问数据的帮助。<br>哪个系统更“好”取决于系统上进程的需求和用户对操作系统的要求。如果系统主要运行数据库应用程序，那么操作系统实现数据库类型的文件并提供操作可能更有效，而不是让每个程序实现相同的操作（可能会有不同的实现方式）。对于<strong>通用系统</strong>，实现基本的文件类型可能更好，以<strong>保持操作系统的大小更小</strong>并允许系统中的进程最大自由度。</p>
<h3 id="13-3-同样，有些系统支持多种类型的文件数据结构，而其他系统则仅支持字节流。每种方法的优缺点是什么？"><a href="#13-3-同样，有些系统支持多种类型的文件数据结构，而其他系统则仅支持字节流。每种方法的优缺点是什么？" class="headerlink" title="13.3. 同样，有些系统支持多种类型的文件数据结构，而其他系统则仅支持字节流。每种方法的优缺点是什么？"></a>13.3. 同样，有些系统支持多种类型的文件数据结构，而其他系统则仅支持字节流。每种方法的优缺点是什么？</h3><p><strong>支持不同文件结构的优点</strong>是这些支持来自操作系统；<strong>应用程序不需要提供支持</strong>。此外，如果系统提供对不同文件结构的支持，它可以比应用程序更有效地实现支持。<br><strong>系统提供对定义文件类型支持的缺点</strong>是它增加了系统的大小。此外，需要文件类型支持的应用程序可能无法在该系统上运行。<br><strong>一种替代策略</strong>是操作系统不定义对文件结构的支持，而是将所有文件视为字节序列。这是<strong>UNIX系统采用的方法</strong>。这种方法的<strong>优点</strong>是它简化了操作系统对文件系统的支持，因为系统不再需要为不同的文件类型提供结构。<strong>此外，它允许应用程序定义文件结构</strong>，避免了系统可能不提供特定应用程序所需的文件定义的情况。</p>
<h3 id="13-4-你能否用单级目录结构模拟多级目录结构，其中可以使用任意长的文件名？如果可以，请解释如何做到，比较这种方案和多级目录方案。如果不行，请解释是什么阻碍了模拟的成功。如果文件名限制为七个字符，你的答案会有什么变化？"><a href="#13-4-你能否用单级目录结构模拟多级目录结构，其中可以使用任意长的文件名？如果可以，请解释如何做到，比较这种方案和多级目录方案。如果不行，请解释是什么阻碍了模拟的成功。如果文件名限制为七个字符，你的答案会有什么变化？" class="headerlink" title="13.4. 你能否用单级目录结构模拟多级目录结构，其中可以使用任意长的文件名？如果可以，请解释如何做到，比较这种方案和多级目录方案。如果不行，请解释是什么阻碍了模拟的成功。如果文件名限制为七个字符，你的答案会有什么变化？"></a>13.4. 你能否用单级目录结构模拟多级目录结构，其中可以使用任意长的文件名？如果可以，请解释如何做到，比较这种方案和多级目录方案。如果不行，请解释是什么阻碍了模拟的成功。如果文件名限制为七个字符，你的答案会有什么变化？</h3><p><strong>如果可以使用任意长的文件名</strong>，那么<strong>可以模拟多级目录结构</strong>。例如，可以使用字符“.”表示子目录的结束。因此，例如，文件名 <code>jim.java.F1</code> 指定 <code>F1</code> 是 <code>java</code> 子目录中的一个文件，而 <code>java</code> 又在根目录 <code>jim</code> 中。如果文件名限制为七个字符，则无法使用此方案，因此通常答案是 <strong>不能</strong>。在这种情况下，<strong>下一种最佳方法</strong>是使用一个特定的文件作为符号表（目录），将任意长的文件名（例如 <code>jim.java.F1</code>）映射为较短的任意名称（例如 <code>XX00743</code>），然后使用这些较短的名称进行实际的文件访问。</p>
<h3 id="13-5-解释-open-和-close-操作的目的。"><a href="#13-5-解释-open-和-close-操作的目的。" class="headerlink" title="13.5. 解释 open() 和 close() 操作的目的。"></a>13.5. 解释 <code>open()</code> 和 <code>close()</code> 操作的目的。</h3><p><code>open()</code> 操作通知系统，指定的文件即将变为活跃状态。<br><code>close()</code> 操作通知系统，指定的文件不再由发出 <code>close</code> 操作的用户使用。</p>
<h3 id="13-6-在某些系统中，子目录可以像普通文件一样被授权用户读取和写入。"><a href="#13-6-在某些系统中，子目录可以像普通文件一样被授权用户读取和写入。" class="headerlink" title="13.6. 在某些系统中，子目录可以像普通文件一样被授权用户读取和写入。"></a>13.6. 在某些系统中，子目录可以像普通文件一样被授权用户读取和写入。</h3><p><strong>a.</strong> 描述可能出现的保护问题。<br><strong>b.</strong> 提出解决这些保护问题的方案。</p>
<p><strong>a.</strong> 目录条目中保存的一项信息是文件位置。如果用户可以修改此位置，那么<strong>他可能访问到其他文件，从而破坏访问保护方案</strong>。<br><strong>b.</strong> 不允许用户直接写入子目录，而应提供系统操作来进行。</p>
<h3 id="13-7-考虑一个支持-5-000-个用户的系统。假设你希望让-4-990-个用户能够访问一个文件。"><a href="#13-7-考虑一个支持-5-000-个用户的系统。假设你希望让-4-990-个用户能够访问一个文件。" class="headerlink" title="13.7. 考虑一个支持 5,000 个用户的系统。假设你希望让 4,990 个用户能够访问一个文件。"></a>13.7. 考虑一个支持 5,000 个用户的系统。假设你希望让 4,990 个用户能够访问一个文件。</h3><p><strong>a.</strong> 如何在 UNIX 中指定这种保护方案？<br><strong>b.</strong> 能否建议另一种比 UNIX 提供的方案更有效的保护方案？</p>
<p><strong>a.</strong> 有两种方法可以实现这一点：  </p>
<ul>
<li><strong>i.</strong> 创建一个包含所有 4,990 个用户名称的访问控制列表。  </li>
<li><strong>ii.</strong> 将这 4,990 个用户放在一个组中，并相应设置组访问权限。这个方案不能总是实现，因为系统对用户组数量和每个组成员的数量可能有限制。</li>
</ul>
<p><strong>b.</strong> <strong>文件的普遍访问</strong>适用于所有用户，除非他们的名称出现在访问控制列表中，并具有不同的访问权限。因此，你可以将剩余的 10 个用户的名称放入访问控制列表，但不给他们任何访问权限。</p>
<h3 id="13-8-研究人员建议，与每个文件关联一个访问控制列表（指定哪些用户可以访问文件及其方式）相比，我们应该为每个用户关联一个用户控制列表（指定用户可以访问哪些文件及其方式）。讨论这两种方案的相对优缺点。"><a href="#13-8-研究人员建议，与每个文件关联一个访问控制列表（指定哪些用户可以访问文件及其方式）相比，我们应该为每个用户关联一个用户控制列表（指定用户可以访问哪些文件及其方式）。讨论这两种方案的相对优缺点。" class="headerlink" title="13.8. 研究人员建议，与每个文件关联一个访问控制列表（指定哪些用户可以访问文件及其方式）相比，我们应该为每个用户关联一个用户控制列表（指定用户可以访问哪些文件及其方式）。讨论这两种方案的相对优缺点。"></a>13.8. 研究人员建议，与每个文件关联一个访问控制列表（指定哪些用户可以访问文件及其方式）相比，我们应该为每个用户关联一个用户控制列表（指定用户可以访问哪些文件及其方式）。讨论这两种方案的相对优缺点。</h3><p><strong>基于文件的控制列表</strong>。因为访问控制信息集中在一个地方，<strong>更容易更改信息，且需要的空间较少</strong>。<br><strong>基于用户的控制列表</strong>。这种方法在<strong>打开文件时开销较少</strong>。</p>
<h2 id="14-第14章-文件系统实现"><a href="#14-第14章-文件系统实现" class="headerlink" title="14. 第14章 文件系统实现"></a>14. 第14章 文件系统实现</h2><h3 id="14-1-考虑一个当前由-100-个块组成的文件。假设文件控制块（以及在索引分配情况下的索引块）已经在内存中。计算对于以下条件的块所需的磁盘-I-O-操作次数，针对连续分配、链接分配和索引（单级）分配策略："><a href="#14-1-考虑一个当前由-100-个块组成的文件。假设文件控制块（以及在索引分配情况下的索引块）已经在内存中。计算对于以下条件的块所需的磁盘-I-O-操作次数，针对连续分配、链接分配和索引（单级）分配策略：" class="headerlink" title="14.1. 考虑一个当前由 100 个块组成的文件。假设文件控制块（以及在索引分配情况下的索引块）已经在内存中。计算对于以下条件的块所需的磁盘 I/O 操作次数，针对连续分配、链接分配和索引（单级）分配策略："></a>14.1. 考虑一个当前由 100 个块组成的文件。假设文件控制块（以及在索引分配情况下的索引块）已经在内存中。计算对于以下条件的块所需的磁盘 I/O 操作次数，针对连续分配、链接分配和索引（单级）分配策略：</h3><p>在连续分配的情况下，假设文件开始时没有空间增长，但末尾有空间增长。还假设要添加的块信息已经存储在内存中。</p>
<ul>
<li><strong>a.</strong> 块被添加到开始位置。</li>
<li><strong>b.</strong> 块被添加到中间位置。</li>
<li><strong>c.</strong> 块被添加到末尾位置。</li>
<li><strong>d.</strong> 块从开始位置删除。</li>
<li><strong>e.</strong> 块从中间删除。</li>
<li><strong>f.</strong> 块从末尾删除。</li>
</ul>
<h3 id="14-2-为什么文件分配的位图必须存储在外部存储设备上，而不能存储在主内存中？"><a href="#14-2-为什么文件分配的位图必须存储在外部存储设备上，而不能存储在主内存中？" class="headerlink" title="14.2. 为什么文件分配的位图必须存储在外部存储设备上，而不能存储在主内存中？"></a>14.2. 为什么文件分配的位图必须存储在外部存储设备上，而不能存储在主内存中？</h3><p><strong>为了避免系统崩溃（内存故障）时丢失空闲空间列表</strong>，如果位图存储在主内存中，系统崩溃后将会丢失此信息。</p>
<h3 id="14-3-考虑一个支持连续分配、链接分配和索引分配策略的系统。在决定哪种策略最适合特定文件时，应该使用什么标准？"><a href="#14-3-考虑一个支持连续分配、链接分配和索引分配策略的系统。在决定哪种策略最适合特定文件时，应该使用什么标准？" class="headerlink" title="14.3. 考虑一个支持连续分配、链接分配和索引分配策略的系统。在决定哪种策略最适合特定文件时，应该使用什么标准？"></a>14.3. 考虑一个支持连续分配、链接分配和索引分配策略的系统。在决定哪种策略最适合特定文件时，应该使用什么标准？</h3><ul>
<li><strong>连续分配</strong>—如果文件通常是顺序访问的，且文件相对较小。  </li>
<li><strong>链接分配</strong>—如果文件较大并且通常是顺序访问的。  </li>
<li><strong>索引分配</strong>—如果文件较大并且通常是随机访问的。</li>
</ul>
<h3 id="14-4-连续分配的一个问题是用户必须预先为每个文件分配足够的空间。如果文件增长超过分配的空间，则必须采取特殊措施。解决此问题的一种方法是定义一个文件结构，包含一个指定大小的初始连续区域。如果该区域已满，操作系统会自动定义一个与初始连续区域链接的溢出区域。如果溢出区域已满，则会分配另一个溢出区域。将此文件实现与标准的连续分配和链接分配实现进行比较。"><a href="#14-4-连续分配的一个问题是用户必须预先为每个文件分配足够的空间。如果文件增长超过分配的空间，则必须采取特殊措施。解决此问题的一种方法是定义一个文件结构，包含一个指定大小的初始连续区域。如果该区域已满，操作系统会自动定义一个与初始连续区域链接的溢出区域。如果溢出区域已满，则会分配另一个溢出区域。将此文件实现与标准的连续分配和链接分配实现进行比较。" class="headerlink" title="14.4. 连续分配的一个问题是用户必须预先为每个文件分配足够的空间。如果文件增长超过分配的空间，则必须采取特殊措施。解决此问题的一种方法是定义一个文件结构，包含一个指定大小的初始连续区域。如果该区域已满，操作系统会自动定义一个与初始连续区域链接的溢出区域。如果溢出区域已满，则会分配另一个溢出区域。将此文件实现与标准的连续分配和链接分配实现进行比较。"></a>14.4. 连续分配的一个问题是用户必须预先为每个文件分配足够的空间。如果文件增长超过分配的空间，则必须采取特殊措施。解决此问题的一种方法是定义一个文件结构，包含一个指定大小的初始连续区域。如果该区域已满，操作系统会自动定义一个与初始连续区域链接的溢出区域。如果溢出区域已满，则会分配另一个溢出区域。将此文件实现与标准的连续分配和链接分配实现进行比较。</h3><p><strong>这种方法比标准的连续分配需要更多的开销</strong>。但<strong>比标准的链接分配需要的开销要少</strong>。</p>
<h3 id="14-5-缓存如何帮助提高性能？为什么系统不使用更多或更大的缓存，如果它们如此有用的话？"><a href="#14-5-缓存如何帮助提高性能？为什么系统不使用更多或更大的缓存，如果它们如此有用的话？" class="headerlink" title="14.5. 缓存如何帮助提高性能？为什么系统不使用更多或更大的缓存，如果它们如此有用的话？"></a>14.5. 缓存如何帮助提高性能？为什么系统不使用更多或更大的缓存，如果它们如此有用的话？</h3><p><strong>缓存</strong>通过将来自较慢设备的数据临时存储在较快的设备（缓存）中，使得不同速度的组件能够更高效地通信。缓存通常比它们为之缓存的设备更昂贵，因此<strong>增加缓存的数量或大小会增加系统成本</strong>。</p>
<h3 id="14-6-为什么操作系统动态分配内部表对用户有利？操作系统为此需要承担什么样的代价？"><a href="#14-6-为什么操作系统动态分配内部表对用户有利？操作系统为此需要承担什么样的代价？" class="headerlink" title="14.6. 为什么操作系统动态分配内部表对用户有利？操作系统为此需要承担什么样的代价？"></a>14.6. 为什么操作系统动态分配内部表对用户有利？操作系统为此需要承担什么样的代价？</h3><p><strong>动态表</strong>允许系统在增长时更具灵活性—表格永远不会超出限制，避免了人为的使用限制。不幸的是，<strong>内核结构和代码变得更加复杂，因此有更多潜在的错误</strong>。<strong>动态表</strong>比静态表使用更多的系统资源，因此随着系统增长，<strong>可能会从系统的其他部分占用资源</strong>。</p>
<h2 id="15-第15章-文件系统内部实现"><a href="#15-第15章-文件系统内部实现" class="headerlink" title="15. 第15章 文件系统内部实现"></a>15. 第15章 文件系统内部实现</h2><h3 id="15-1-解释-VFS-层如何使操作系统能够轻松支持多种类型的文件系统。"><a href="#15-1-解释-VFS-层如何使操作系统能够轻松支持多种类型的文件系统。" class="headerlink" title="15.1. 解释 VFS 层如何使操作系统能够轻松支持多种类型的文件系统。"></a>15.1. 解释 VFS 层如何使操作系统能够轻松支持多种类型的文件系统。</h3><p><strong>VFS</strong> 引入了文件系统实现中的间接层。在很多方面，它类似于面向对象编程技术。系统调用可以以通用方式（独立于文件系统类型）进行。每种文件系统类型提供其函数调用和数据结构给 <strong>VFS 层</strong>。系统调用会在 <strong>VFS 层</strong> 被转换成适合目标文件系统的特定函数。调用程序不包含文件系统特定的代码，系统调用结构的上层也同样是文件系统独立的。<strong>VFS 层的转换</strong>将这些通用调用转变为文件系统特定的操作。</p>
<h3 id="15-2-为什么在一个系统中要有多种文件系统类型？"><a href="#15-2-为什么在一个系统中要有多种文件系统类型？" class="headerlink" title="15.2. 为什么在一个系统中要有多种文件系统类型？"></a>15.2. 为什么在一个系统中要有多种文件系统类型？</h3><p>文件系统可以根据特定的用途进行设计和实现，并为这些用途进行优化。考虑虚拟内存文件系统与二级存储文件系统的区别。基于内存的文件系统不必担心碎片化，也不需要在电力丧失时保持数据结构持久化。还有一些专用文件系统，如 <strong>procfs 文件系统</strong>，旨在为像进程名称空间和进程资源使用等系统方面提供便捷的文件系统接口。</p>
<h3 id="15-3-在实现了-procfs-文件系统-的-Unix-或-Linux-系统上，如何使用-procfs-接口-来探索进程名称空间？通过此接口可以查看哪些进程方面的内容？如果没有-procfs-文件系统，如何收集相同的信息？"><a href="#15-3-在实现了-procfs-文件系统-的-Unix-或-Linux-系统上，如何使用-procfs-接口-来探索进程名称空间？通过此接口可以查看哪些进程方面的内容？如果没有-procfs-文件系统，如何收集相同的信息？" class="headerlink" title="15.3. 在实现了 procfs 文件系统 的 Unix 或 Linux 系统上，如何使用 procfs 接口 来探索进程名称空间？通过此接口可以查看哪些进程方面的内容？如果没有 procfs 文件系统，如何收集相同的信息？"></a>15.3. 在实现了 <strong>procfs 文件系统</strong> 的 Unix 或 Linux 系统上，如何使用 <strong>procfs 接口</strong> 来探索进程名称空间？通过此接口可以查看哪些进程方面的内容？如果没有 <strong>procfs 文件系统</strong>，如何收集相同的信息？</h3><p>在包含 <strong>procfs 假文件系统</strong> 的系统上，具体实现可能有所不同，但通常文件系统挂载在 <code>/proc</code> 目录下，通过文件系统命令探索它可以揭示以下信息：</p>
<ul>
<li>每个进程由其 <strong>进程ID</strong> 表示，因此通过计数它们可以得出系统中的进程数量。</li>
<li>每个进程ID目录下包含关于进程状态的详细信息，如当前工作目录、启动进程时使用的命令行、优先级信息、内存使用信息、锁信息、打开文件信息等。</li>
<li>一些 <strong>procfs</strong> 还提供与其他内核结构的接口，如 <strong>DMA 结构、设备列表、文件系统列表</strong> 等。</li>
</ul>
<p>具体信息可以参考系统的 <strong>proc(5) 手册页</strong>。如果没有 <strong>procfs</strong>，要提供相同的信息，必须使用不同的信息类型进行系统调用，或者通过 <code>/dev/kmem</code> 或 <code>/dev/sys</code> 打开内核内存空间。然后，使用这些接口的程序需要被编写出来，以提取数据并将其呈现为人类可理解的形式。参见 <a target="_blank" rel="noopener" href="http://osxbook.com/book/bonus/ancient/procfs">http://osxbook.com/book/bonus/ancient/procfs</a> 来深入了解 <strong>procfs</strong> 与没有它的情况。</p>
<h3 id="15-4-为什么有些系统将挂载的文件系统集成到根文件系统命名结构中，而其他系统则使用单独的命名方法来命名挂载的文件系统？"><a href="#15-4-为什么有些系统将挂载的文件系统集成到根文件系统命名结构中，而其他系统则使用单独的命名方法来命名挂载的文件系统？" class="headerlink" title="15.4. 为什么有些系统将挂载的文件系统集成到根文件系统命名结构中，而其他系统则使用单独的命名方法来命名挂载的文件系统？"></a>15.4. 为什么有些系统将挂载的文件系统集成到根文件系统命名结构中，而其他系统则使用单独的命名方法来命名挂载的文件系统？</h3><p>正如操作系统设计中的许多方面，选择可以是任意的，也可能基于一些小的实现细节，并且在没有正当理由的情况下持续存在。<strong>通常</strong>，关于文件系统挂载的集成方法，<strong>与根文件系统命名的集成</strong>证明了更大的灵活性和实用性，而单独的挂载点命名方法则较少采用，因此在大多数文件系统中占主导地位。</p>
<h3 id="15-5-给定一个远程文件访问设施，如-ftp，为什么像-NFS-这样的远程文件系统会被创建？"><a href="#15-5-给定一个远程文件访问设施，如-ftp，为什么像-NFS-这样的远程文件系统会被创建？" class="headerlink" title="15.5. 给定一个远程文件访问设施，如 ftp，为什么像 NFS 这样的远程文件系统会被创建？"></a>15.5. 给定一个远程文件访问设施，如 ftp，为什么像 NFS 这样的远程文件系统会被创建？</h3><p>计算机系统的用户大多数情况下重视易用性。操作系统越通用、越广泛使用，其操作就应该越无缝。对于远程文件访问，<strong>用户更倾向于使用熟悉的设施</strong>（如文件系统接口），而不是分离的命令。而且，<strong>因为文件系统经过验证、良好集成并功能完备</strong>，现有的工具、脚本和使用案例也可以像本地文件系统一样适用于远程文件系统，只需使用文件系统接口来进行远程文件访问。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">PIQUE</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%A0%E9%A2%98/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%A0%E9%A2%98/">http://example.com/2025/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%A0%E9%A2%98/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%A0%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">PIQUE</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/./image/image1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/06/09/OS_Words/OS_Words/" title="OS_Words"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">OS_Words</div></div><div class="info-2"><div class="info-item-1">上下文的组成 在操作系统中，上下文（Context） 指的是进程或线程在执行期间所需要的所有信息的集合，通常包括寄存器的值、内存的状态、程序计数器等。当操作系统进行任务切换、进程调度、系统调用或中断处理时，需要保存和恢复进程的上下文，确保进程可以在暂停的地方继续执行。 上下文切换（Context...</div></div></div></a><a class="pagination-related" href="/2025/06/07/%E7%AC%AC%E5%85%AB%E7%AB%A0%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E7%AC%AC%E5%85%AB%E7%AB%A0%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/" title="第八章文件管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">第八章文件管理</div></div><div class="info-2"><div class="info-item-1">1....</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/./image/image1.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">PIQUE</div><div class="author-info-description">这是PIQUE的网页，欢迎访问</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/pique2233"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%AC%AC1%E7%AB%A0-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">1. 第1章 介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%89%E4%B8%AA%E4%B8%BB%E8%A6%81%E7%9B%AE%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">1.1. 操作系统的三个主要目的是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%88%91%E4%BB%AC%E5%BC%BA%E8%B0%83%E4%BA%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%AB%98%E6%95%88%E5%88%A9%E7%94%A8%E8%AE%A1%E7%AE%97%E7%A1%AC%E4%BB%B6%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7%E3%80%82%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E8%AF%A5%E6%94%BE%E5%BC%83%E8%BF%99%E4%B8%80%E5%8E%9F%E5%88%99%EF%BC%8C%E5%8E%BB%E2%80%9C%E6%B5%AA%E8%B4%B9%E2%80%9D%E8%B5%84%E6%BA%90%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E7%A7%8D%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%99%85%E4%B8%8A%E5%B9%B6%E4%B8%8D%E6%B5%AA%E8%B4%B9%E8%B5%84%E6%BA%90%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">1.2. 我们强调了操作系统高效利用计算硬件的必要性。在什么情况下操作系统应该放弃这一原则，去“浪费”资源？为什么这种系统实际上并不浪费资源？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%9C%A8%E4%B8%BA%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E7%BC%96%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%97%B6%EF%BC%8C%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E9%A1%BB%E5%85%8B%E6%9C%8D%E7%9A%84%E4%B8%BB%E8%A6%81%E5%9B%B0%E9%9A%BE%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">1.3. 在为实时环境编写操作系统时，程序员必须克服的主要困难是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E8%80%83%E8%99%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%84%E7%A7%8D%E5%AE%9A%E4%B9%89%EF%BC%8C%E6%98%AF%E5%90%A6%E5%BA%94%E8%AF%A5%E5%B0%86%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%A6%82%E7%BD%91%E9%A1%B5%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8C%E9%82%AE%E4%BB%B6%E7%A8%8B%E5%BA%8F%E5%8C%85%E5%90%AB%E5%9C%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%EF%BC%9F%E8%AF%B7%E5%88%86%E5%88%AB%E6%94%AF%E6%8C%81%E5%92%8C%E5%8F%8D%E5%AF%B9%E7%9A%84%E8%AE%BA%E7%82%B9%E3%80%82"><span class="toc-number">1.4.</span> <span class="toc-text">1.4. 考虑操作系统的各种定义，是否应该将应用程序如网页浏览器和邮件程序包含在操作系统中？请分别支持和反对的论点。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E5%86%85%E6%A0%B8%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%86%E5%A6%82%E4%BD%95%E4%BD%9C%E4%B8%BA%E4%BF%9D%E6%8A%A4%EF%BC%88%E5%AE%89%E5%85%A8%EF%BC%89%E7%9A%84%E5%9F%BA%E7%A1%80%E5%BD%A2%E5%BC%8F%E8%B5%B7%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.5.</span> <span class="toc-text">1.5. 内核模式和用户模式的区分如何作为保护（安全）的基础形式起作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E4%BB%A5%E4%B8%8B%E5%93%AA%E4%BA%9B%E6%8C%87%E4%BB%A4%E5%BA%94%E8%AF%A5%E6%98%AF%E7%89%B9%E6%9D%83%E6%8C%87%E4%BB%A4%EF%BC%9F"><span class="toc-number">1.6.</span> <span class="toc-text">1.6. 以下哪些指令应该是特权指令？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-%E4%B8%80%E4%BA%9B%E6%97%A9%E6%9C%9F%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%BF%87%E5%B0%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%94%BE%E7%BD%AE%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E4%B8%AD%E6%9D%A5%E4%BF%9D%E6%8A%A4%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8C%E8%AF%A5%E5%88%86%E5%8C%BA%E6%97%A2%E4%B8%8D%E8%83%BD%E8%A2%AB%E7%94%A8%E6%88%B7%E4%BD%9C%E4%B8%9A%E4%B9%9F%E4%B8%8D%E8%83%BD%E8%A2%AB%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%AC%E8%BA%AB%E4%BF%AE%E6%94%B9%E3%80%82%E6%8F%8F%E8%BF%B0%E8%BF%99%E7%A7%8D%E6%96%B9%E6%A1%88%E5%8F%AF%E8%83%BD%E5%B8%A6%E6%9D%A5%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%9B%B0%E9%9A%BE%E3%80%82"><span class="toc-number">1.7.</span> <span class="toc-text">1.7. 一些早期的计算机通过将操作系统放置在一个内存分区中来保护操作系统，该分区既不能被用户作业也不能被操作系统本身修改。描述这种方案可能带来的两种困难。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-%E4%B8%80%E4%BA%9B-CPU-%E6%8F%90%E4%BE%9B%E4%BA%86%E5%A4%9A%E4%BA%8E%E4%B8%A4%E7%A7%8D%E7%9A%84%E6%93%8D%E4%BD%9C%E6%A8%A1%E5%BC%8F%E3%80%82%E4%BB%A5%E4%B8%8B%E6%98%AF%E8%BF%99%E5%87%A0%E7%A7%8D%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%8F%AF%E8%83%BD%E7%94%A8%E9%80%94%EF%BC%9A"><span class="toc-number">1.8.</span> <span class="toc-text">1.8. 一些 CPU 提供了多于两种的操作模式。以下是这几种模式的两种可能用途：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-%E5%AE%9A%E6%97%B6%E5%99%A8%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E8%AE%A1%E7%AE%97%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4%E3%80%82%E7%AE%80%E8%A6%81%E6%8F%8F%E8%BF%B0%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%BF%99%E4%B8%80%E7%82%B9%E3%80%82"><span class="toc-number">1.9.</span> <span class="toc-text">1.9. 定时器可以用来计算当前时间。简要描述如何实现这一点。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-10-%E7%BB%99%E5%87%BA%E4%B8%A4%E4%B8%AA%E7%BC%93%E5%AD%98%E6%9C%89%E7%94%A8%E7%9A%84%E7%90%86%E7%94%B1%E3%80%82%E5%AE%83%E4%BB%AC%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F%E5%AE%83%E4%BB%AC%E5%BC%95%E5%8F%91%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F%E5%A6%82%E6%9E%9C%E7%BC%93%E5%AD%98%E5%8F%AF%E4%BB%A5%E5%81%9A%E5%BE%97%E5%92%8C%E5%AE%83%E6%89%80%E7%BC%93%E5%AD%98%E7%9A%84%E8%AE%BE%E5%A4%87%E4%B8%80%E6%A0%B7%E5%A4%A7%EF%BC%88%E4%BE%8B%E5%A6%82%EF%BC%8C%E7%BC%93%E5%AD%98%E5%92%8C%E7%A3%81%E7%9B%98%E4%B8%80%E6%A0%B7%E5%A4%A7%EF%BC%89%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8A%8A%E5%AE%83%E5%81%9A%E5%BE%97%E9%82%A3%E4%B9%88%E5%A4%A7%EF%BC%8C%E6%B6%88%E9%99%A4%E8%AE%BE%E5%A4%87%EF%BC%9F"><span class="toc-number">1.10.</span> <span class="toc-text">1.10. 给出两个缓存有用的理由。它们解决了什么问题？它们引发了什么问题？如果缓存可以做得和它所缓存的设备一样大（例如，缓存和磁盘一样大），为什么不把它做得那么大，消除设备？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-11-%E5%8C%BA%E5%88%86%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%82%B9%E5%AF%B9%E7%82%B9%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E3%80%82"><span class="toc-number">1.11.</span> <span class="toc-text">1.11. 区分客户端-服务器模型和点对点模型的分布式系统。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%AC%AC2%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">2. 第2章 操作系统结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E7%9B%AE%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">2.1. 系统调用的目的是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%91%BD%E4%BB%A4%E8%A7%A3%E9%87%8A%E5%99%A8%E7%9A%84%E7%9B%AE%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%83%E9%80%9A%E5%B8%B8%E4%B8%8E%E5%86%85%E6%A0%B8%E5%88%86%E5%BC%80%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">2.2. 命令解释器的目的是什么？为什么它通常与内核分开？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%9C%A8-UNIX-%E7%B3%BB%E7%BB%9F%E4%B8%AD%EF%BC%8C%E5%91%BD%E4%BB%A4%E8%A7%A3%E9%87%8A%E5%99%A8%E6%88%96-shell-%E6%89%A7%E8%A1%8C%E5%93%AA%E4%BA%9B%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%9D%A5%E5%90%AF%E5%8A%A8%E6%96%B0%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">2.3. 在 UNIX 系统中，命令解释器或 shell 执行哪些系统调用来启动新进程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E7%B3%BB%E7%BB%9F%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%9B%AE%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">2.4. 系统程序的目的是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%88%86%E5%B1%82%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%88%86%E5%B1%82%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E7%9A%84%E7%BC%BA%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">2.5. 分层设计方法的主要优点是什么？分层设计方法的缺点是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E5%88%97%E5%87%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8F%90%E4%BE%9B%E7%9A%84%E4%BA%94%E9%A1%B9%E6%9C%8D%E5%8A%A1%EF%BC%8C%E5%B9%B6%E8%A7%A3%E9%87%8A%E6%AF%8F%E9%A1%B9%E5%A6%82%E4%BD%95%E4%B8%BA%E7%94%A8%E6%88%B7%E6%8F%90%E4%BE%9B%E4%BE%BF%E5%88%A9%E3%80%82%E5%9C%A8%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8B%E7%94%A8%E6%88%B7%E7%BA%A7%E7%A8%8B%E5%BA%8F%E6%97%A0%E6%B3%95%E6%8F%90%E4%BE%9B%E8%BF%99%E4%BA%9B%E6%9C%8D%E5%8A%A1%EF%BC%9F%E8%AF%B7%E8%A7%A3%E9%87%8A%E4%BD%A0%E7%9A%84%E7%AD%94%E6%A1%88%E3%80%82"><span class="toc-number">2.6.</span> <span class="toc-text">2.6. 列出操作系统提供的五项服务，并解释每项如何为用户提供便利。在哪些情况下用户级程序无法提供这些服务？请解释你的答案。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%BA%9B%E7%B3%BB%E7%BB%9F%E5%B0%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%98%E5%82%A8%E5%9C%A8%E5%9B%BA%E4%BB%B6%E4%B8%AD%EF%BC%8C%E8%80%8C%E5%85%B6%E4%BB%96%E7%B3%BB%E7%BB%9F%E5%88%99%E5%B0%86%E5%85%B6%E5%AD%98%E5%82%A8%E5%9C%A8%E7%A3%81%E7%9B%98%E4%B8%8A%EF%BC%9F"><span class="toc-number">2.7.</span> <span class="toc-text">2.7. 为什么有些系统将操作系统存储在固件中，而其他系统则将其存储在磁盘上？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%B3%BB%E7%BB%9F%EF%BC%8C%E5%85%81%E8%AE%B8%E4%BB%8E%E5%A4%9A%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E9%80%89%E6%8B%A9%E5%90%AF%E5%8A%A8%EF%BC%9F%E5%BC%95%E5%AF%BC%E7%A8%8B%E5%BA%8F%E9%9C%80%E8%A6%81%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.8.</span> <span class="toc-text">2.8. 如何设计一个系统，允许从多个操作系统中选择启动？引导程序需要做什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%AC%AC3%E7%AB%A0-%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">3. 第3章 进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E4%BD%BF%E7%94%A8%E5%9B%BE-3-30-%E4%B8%AD%E6%98%BE%E7%A4%BA%E7%9A%84%E7%A8%8B%E5%BA%8F%EF%BC%8C%E8%A7%A3%E9%87%8A%E5%9C%A8-LINE-A-%E5%A4%84%E7%9A%84%E8%BE%93%E5%87%BA%E6%98%AF%E4%BB%80%E4%B9%88%E3%80%82"><span class="toc-number">3.1.</span> <span class="toc-text">3.1. 使用图 3.30 中显示的程序，解释在 LINE A 处的输出是什么。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E8%8B%B9%E6%9E%9C%E5%85%AC%E5%8F%B8%E6%97%A9%E6%9C%9F%E7%89%88%E6%9C%AC%E7%9A%84-iOS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%B2%A1%E6%9C%89%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86%E8%83%BD%E5%8A%9B%E3%80%82%E8%AE%A8%E8%AE%BA%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86%E4%B8%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A2%9E%E5%8A%A0%E7%9A%84%E4%B8%89%E5%A4%A7%E5%A4%8D%E6%9D%82%E6%80%A7%E3%80%82"><span class="toc-number">3.2.</span> <span class="toc-text">3.3. 苹果公司早期版本的 iOS 操作系统没有并发处理能力。讨论并发处理为操作系统增加的三大复杂性。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E4%B8%80%E4%BA%9B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%8F%90%E4%BE%9B%E5%A4%9A%E4%B8%AA%E5%AF%84%E5%AD%98%E5%99%A8%E9%9B%86%E3%80%82%E5%A6%82%E6%9E%9C%E6%96%B0%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%B7%B2%E7%BB%8F%E5%8A%A0%E8%BD%BD%E5%88%B0%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E5%AF%84%E5%AD%98%E5%99%A8%E9%9B%86%E4%B8%AD%EF%BC%8C%E5%8F%91%E7%94%9F%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E6%97%B6%E4%BC%9A%E6%80%8E%E6%A0%B7%EF%BC%9F%E5%A6%82%E6%9E%9C%E6%96%B0%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%EF%BC%8C%E8%80%8C%E6%89%80%E6%9C%89%E5%AF%84%E5%AD%98%E5%99%A8%E9%9B%86%E9%83%BD%E5%9C%A8%E4%BD%BF%E7%94%A8%E4%B8%AD%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%EF%BC%9F"><span class="toc-number">3.3.</span> <span class="toc-text">3.4. 一些计算机系统提供多个寄存器集。如果新的上下文已经加载到其中一个寄存器集中，发生上下文切换时会怎样？如果新的上下文在内存中，而所有寄存器集都在使用中，会发生什么情况？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E5%BD%93%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8-fork-%E6%93%8D%E4%BD%9C%E5%88%9B%E5%BB%BA%E6%96%B0%E8%BF%9B%E7%A8%8B%E6%97%B6%EF%BC%8C%E4%BB%A5%E4%B8%8B%E5%93%AA%E4%B8%AA%E7%8A%B6%E6%80%81%E6%98%AF%E7%88%B6%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%85%B1%E4%BA%AB%E7%9A%84%EF%BC%9F"><span class="toc-number">3.4.</span> <span class="toc-text">3.5. 当进程使用 fork() 操作创建新进程时，以下哪个状态是父进程和子进程共享的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E8%80%83%E8%99%91-%E2%80%9C%E6%81%B0%E5%A5%BD%E4%B8%80%E6%AC%A1%E2%80%9D%EF%BC%88exactly-once%EF%BC%89%E8%AF%AD%E4%B9%89%E4%B8%8E-RPC-%E6%9C%BA%E5%88%B6%E7%9A%84%E5%85%B3%E7%B3%BB%E3%80%82%E5%A6%82%E6%9E%9C%E7%94%B1%E4%BA%8E%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98%EF%BC%8C%E5%8F%91%E9%80%81%E5%9B%9E%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84-ACK-%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%EF%BC%8C%E5%AE%9E%E6%96%BD%E6%AD%A4%E8%AF%AD%E4%B9%89%E7%9A%84%E7%AE%97%E6%B3%95%E6%98%AF%E5%90%A6%E4%BB%8D%E7%84%B6%E6%AD%A3%E7%A1%AE%E6%89%A7%E8%A1%8C%EF%BC%9F%E6%8F%8F%E8%BF%B0%E6%B6%88%E6%81%AF%E7%9A%84%E5%BA%8F%E5%88%97%EF%BC%8C%E5%B9%B6%E8%AE%A8%E8%AE%BA%E2%80%9C%E6%81%B0%E5%A5%BD%E4%B8%80%E6%AC%A1%E2%80%9D%E6%98%AF%E5%90%A6%E4%BB%8D%E7%84%B6%E5%BE%97%E5%88%B0%E4%BF%9D%E6%8C%81%E3%80%82"><span class="toc-number">3.5.</span> <span class="toc-text">3.6. 考虑 “恰好一次”（exactly once）语义与 RPC 机制的关系。如果由于网络问题，发送回客户端的 ACK 消息丢失，实施此语义的算法是否仍然正确执行？描述消息的序列，并讨论“恰好一次”是否仍然得到保持。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-%E5%81%87%E8%AE%BE%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%B9%E6%98%93%E5%8F%97%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%85%E9%9A%9C%E7%9A%84%E5%BD%B1%E5%93%8D%E3%80%82%E4%B8%BA%E4%BA%86%E4%BF%9D%E8%AF%81%E6%89%A7%E8%A1%8C-RPC-%E6%97%B6%E7%9A%84-%E2%80%9C%E6%81%B0%E5%A5%BD%E4%B8%80%E6%AC%A1%E2%80%9D-%E8%AF%AD%E4%B9%89%EF%BC%8C%E9%9C%80%E8%A6%81%E5%93%AA%E4%BA%9B%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">3.6.</span> <span class="toc-text">3.7. 假设一个分布式系统容易受到服务器故障的影响。为了保证执行 RPC 时的 “恰好一次” 语义，需要哪些机制？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="toc-number">4.</span> <span class="toc-text">4. 第四章 线程与并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%8F%90%E4%BE%9B%E4%B8%89%E4%B8%AA%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%EF%BC%8C%E5%85%B6%E4%B8%AD%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%AF%94%E5%8D%95%E7%BA%BF%E7%A8%8B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%8F%90%E4%BE%9B%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%80%A7%E8%83%BD%E3%80%82"><span class="toc-number">4.1.</span> <span class="toc-text">4.1. 提供三个编程示例，其中多线程比单线程解决方案提供更好的性能。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E4%BD%BF%E7%94%A8-Amdahl-%E5%AE%9A%E5%BE%8B%EF%BC%8C%E8%AE%A1%E7%AE%97%E4%B8%80%E4%B8%AA%E5%85%B7%E6%9C%89-60-%E5%B9%B6%E8%A1%8C%E7%BB%84%E4%BB%B6%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%9C%A8-a-%E4%B8%A4%E4%B8%AA%E5%A4%84%E7%90%86%E6%A0%B8%E5%BF%83%E5%92%8C-b-%E5%9B%9B%E4%B8%AA%E5%A4%84%E7%90%86%E6%A0%B8%E5%BF%83%E4%B8%8A%E7%9A%84%E5%8A%A0%E9%80%9F%E5%A2%9E%E7%9B%8A%E3%80%82"><span class="toc-number">4.2.</span> <span class="toc-text">4.2. 使用 Amdahl 定律，计算一个具有 60% 并行组件的应用程序在 (a) 两个处理核心和 (b) 四个处理核心上的加速增益。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%9C%A8-4-1-%E8%8A%82%E4%B8%AD%E6%8F%8F%E8%BF%B0%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B-Web-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B1%95%E7%A4%BA%E4%BA%86%E4%BB%BB%E5%8A%A1%E5%B9%B6%E8%A1%8C%E6%80%A7%E8%BF%98%E6%98%AF%E6%95%B0%E6%8D%AE%E5%B9%B6%E8%A1%8C%E6%80%A7%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">4.3. 在 4.1 节中描述的多线程 Web 服务器展示了任务并行性还是数据并行性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%B8%80%E7%A7%8D%E7%B1%BB%E5%9E%8B%E4%BC%98%E4%BA%8E%E5%8F%A6%E4%B8%80%E7%A7%8D%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">4.4. 用户级线程和内核级线程之间的两个区别是什么？在什么情况下一种类型优于另一种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E6%8F%8F%E8%BF%B0%E5%86%85%E6%A0%B8%E5%9C%A8%E8%BF%9B%E8%A1%8C%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E6%97%B6%E6%89%80%E9%87%87%E5%8F%96%E7%9A%84%E6%93%8D%E4%BD%9C%E3%80%82"><span class="toc-number">4.5.</span> <span class="toc-text">4.5. 描述内核在进行内核级线程的上下文切换时所采取的操作。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%97%B6%E4%BD%BF%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E8%B5%84%E6%BA%90%EF%BC%9F%E5%AE%83%E4%BB%AC%E4%B8%8E%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E6%97%B6%E4%BD%BF%E7%94%A8%E7%9A%84%E8%B5%84%E6%BA%90%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">4.6.</span> <span class="toc-text">4.6. 创建线程时使用了哪些资源？它们与创建进程时使用的资源有何不同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-%E5%81%87%E8%AE%BE%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%A8%A1%E5%9E%8B%E5%B0%86%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B%E6%98%A0%E5%B0%84%E5%88%B0%E5%86%85%E6%A0%B8%EF%BC%8C%E5%B9%B6%E4%B8%94%E6%98%A0%E5%B0%84%E6%98%AF%E9%80%9A%E8%BF%87-LWPs%EF%BC%88%E8%BD%BB%E9%87%8F%E7%BA%A7%E8%BF%9B%E7%A8%8B%EF%BC%89%E8%BF%9B%E8%A1%8C%E7%9A%84%E3%80%82%E6%AD%A4%E5%A4%96%EF%BC%8C%E7%B3%BB%E7%BB%9F%E5%85%81%E8%AE%B8%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E4%B8%BA%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F%E5%88%9B%E5%BB%BA%E5%AE%9E%E6%97%B6%E7%BA%BF%E7%A8%8B%E3%80%82%E6%98%AF%E5%90%A6%E6%9C%89%E5%BF%85%E8%A6%81%E5%B0%86%E5%AE%9E%E6%97%B6%E7%BA%BF%E7%A8%8B%E7%BB%91%E5%AE%9A%E5%88%B0-LWP%EF%BC%9F%E8%A7%A3%E9%87%8A%E3%80%82"><span class="toc-number">4.7.</span> <span class="toc-text">4.7. 假设操作系统使用多对多模型将用户级线程映射到内核，并且映射是通过 LWPs（轻量级进程）进行的。此外，系统允许开发人员为实时系统创建实时线程。是否有必要将实时线程绑定到 LWP？解释。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7"><span class="toc-number">5.</span> <span class="toc-text">6. 第六章 同步工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%9C%A8-6-4-%E8%8A%82%E4%B8%AD%EF%BC%8C%E6%88%91%E4%BB%AC%E6%8F%90%E5%88%B0%E9%A2%91%E7%B9%81%E7%A6%81%E7%94%A8%E4%B8%AD%E6%96%AD%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%BD%B1%E5%93%8D%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F%E3%80%82%E8%A7%A3%E9%87%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%8F%91%E7%94%9F%E8%BF%99%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E6%9C%80%E5%B0%8F%E5%8C%96%E8%BF%99%E7%A7%8D%E5%BD%B1%E5%93%8D%E3%80%82"><span class="toc-number">5.1.</span> <span class="toc-text">6.1. 在 6.4 节中，我们提到频繁禁用中断可能会影响系统时钟。解释为什么会发生这种情况，以及如何最小化这种影响。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BF%99%E7%AD%89%E5%BE%85%EF%BC%9F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E8%BF%98%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%AD%89%E5%BE%85%EF%BC%9F%E5%BF%99%E7%AD%89%E5%BE%85%E5%8F%AF%E4%BB%A5%E5%AE%8C%E5%85%A8%E9%81%BF%E5%85%8D%E5%90%97%EF%BC%9F%E8%A7%A3%E9%87%8A%E4%BD%A0%E7%9A%84%E7%AD%94%E6%A1%88%E3%80%82"><span class="toc-number">5.2.</span> <span class="toc-text">6.2. 什么是忙等待？操作系统中还有哪些类型的等待？忙等待可以完全避免吗？解释你的答案。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E8%A7%A3%E9%87%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%87%AA%E6%97%8B%E9%94%81%E4%B8%8D%E9%80%82%E7%94%A8%E4%BA%8E%E5%8D%95%E5%A4%84%E7%90%86%E5%99%A8%E7%B3%BB%E7%BB%9F%EF%BC%8C%E4%BD%86%E5%9C%A8%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%B8%B8%E8%A2%AB%E4%BD%BF%E7%94%A8%E3%80%82"><span class="toc-number">5.3.</span> <span class="toc-text">6.3. 解释为什么自旋锁不适用于单处理器系统，但在多处理器系统中常被使用。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E8%AF%81%E6%98%8E%E5%A6%82%E6%9E%9C-wait-%E5%92%8C-signal-%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%93%8D%E4%BD%9C%E4%B8%8D%E6%98%AF%E5%8E%9F%E5%AD%90%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%8C%E9%82%A3%E4%B9%88%E4%BA%92%E6%96%A5%E5%8F%AF%E8%83%BD%E4%BC%9A%E8%A2%AB%E7%A0%B4%E5%9D%8F%E3%80%82"><span class="toc-number">5.4.</span> <span class="toc-text">6.4. 证明如果 wait() 和 signal() 信号量操作不是原子执行的，那么互斥可能会被破坏。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-%E8%AF%B4%E6%98%8E%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9D%A5%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E4%BA%92%E6%96%A5%E3%80%82"><span class="toc-number">5.5.</span> <span class="toc-text">6.5. 说明如何使用二进制信号量来实现进程间的互斥。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6%E5%9C%A8%E8%AE%B8%E5%A4%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%98%AF%E5%8F%AF%E8%83%BD%E7%9A%84%E3%80%82%E8%80%83%E8%99%91%E4%B8%80%E4%B8%AA%E9%93%B6%E8%A1%8C%E7%B3%BB%E7%BB%9F%EF%BC%8C%E8%AF%A5%E7%B3%BB%E7%BB%9F%E9%80%9A%E8%BF%87%E4%B8%A4%E4%B8%AA%E5%87%BD%E6%95%B0%E7%BB%B4%E6%8A%A4%E8%B4%A6%E6%88%B7%E4%BD%99%E9%A2%9D%EF%BC%9Adeposit-amount-%E5%92%8C-withdraw-amount-%E3%80%82%E8%BF%99%E4%B8%A4%E4%B8%AA%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E8%A6%81%E5%AD%98%E5%85%A5%E6%88%96%E5%8F%96%E5%87%BA%E7%9A%84%E9%87%91%E9%A2%9D%E3%80%82%E5%81%87%E8%AE%BE%E4%B8%88%E5%A4%AB%E5%92%8C%E5%A6%BB%E5%AD%90%E5%85%B1%E5%90%8C%E6%8B%A5%E6%9C%89%E4%B8%80%E4%B8%AA%E9%93%B6%E8%A1%8C%E8%B4%A6%E6%88%B7%E3%80%82%E4%B8%8E%E6%AD%A4%E5%90%8C%E6%97%B6%EF%BC%8C%E4%B8%88%E5%A4%AB%E8%B0%83%E7%94%A8-withdraw-%E5%87%BD%E6%95%B0%EF%BC%8C%E5%A6%BB%E5%AD%90%E8%B0%83%E7%94%A8-deposit-%E3%80%82%E6%8F%8F%E8%BF%B0%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%91%E7%94%9F%E7%9A%84%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E8%BF%99%E7%A7%8D%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6%E5%8F%91%E7%94%9F%E3%80%82"><span class="toc-number">5.6.</span> <span class="toc-text">6.6. 竞争条件在许多计算机系统中是可能的。考虑一个银行系统，该系统通过两个函数维护账户余额：deposit(amount) 和 withdraw(amount)。这两个函数传递要存入或取出的金额。假设丈夫和妻子共同拥有一个银行账户。与此同时，丈夫调用 withdraw() 函数，妻子调用 deposit()。描述竞争条件是如何发生的，以及如何防止这种竞争条件发生。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%90%8C%E6%AD%A5%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.</span> <span class="toc-text">7. 第七章 同步示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E8%A7%A3%E9%87%8A%E4%B8%BA%E4%BB%80%E4%B9%88-Windows-%E5%92%8C-Linux-%E5%AE%9E%E7%8E%B0%E4%BA%86%E5%A4%9A%E7%A7%8D%E9%94%81%E6%9C%BA%E5%88%B6%E3%80%82%E6%8F%8F%E8%BF%B0%E5%AE%83%E4%BB%AC%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BD%BF%E7%94%A8%E8%87%AA%E6%97%8B%E9%94%81%E3%80%81%E4%BA%92%E6%96%A5%E9%94%81%E3%80%81%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%92%8C%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%EF%BC%8C%E5%B9%B6%E8%A7%A3%E9%87%8A%E6%AF%8F%E7%A7%8D%E6%9C%BA%E5%88%B6%E7%9A%84%E9%9C%80%E8%A6%81%E3%80%82"><span class="toc-number">6.1.</span> <span class="toc-text">7.1. 解释为什么 Windows 和 Linux 实现了多种锁机制。描述它们在什么情况下使用自旋锁、互斥锁、信号量和条件变量，并解释每种机制的需要。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-Windows-%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%80%E7%A7%8D%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%EF%BC%8C%E7%A7%B0%E4%B8%BA%E7%AE%80%E5%8C%96%E7%9A%84%E8%AF%BB%E5%86%99%E9%94%81%EF%BC%88slim-reader-writer-locks%EF%BC%89%E3%80%82%E8%80%8C%E5%A4%A7%E5%A4%9A%E6%95%B0%E8%AF%BB%E5%86%99%E9%94%81%E5%AE%9E%E7%8E%B0%E5%80%BE%E5%90%91%E4%BA%8E%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E8%AF%BB%E8%80%85%E6%88%96%E5%86%99%E8%80%85%EF%BC%8C%E6%88%96%E8%80%85%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8-FIFO-%E7%AD%96%E7%95%A5%E6%8E%92%E5%BA%8F%E7%AD%89%E5%BE%85%E7%BA%BF%E7%A8%8B%EF%BC%8C%E7%AE%80%E5%8C%96%E7%9A%84%E8%AF%BB%E5%86%99%E9%94%81%E6%97%A2%E4%B8%8D%E5%81%8F%E5%90%91%E8%AF%BB%E8%80%85%E4%B9%9F%E4%B8%8D%E5%81%8F%E5%90%91%E5%86%99%E8%80%85%EF%BC%8C%E7%AD%89%E5%BE%85%E7%BA%BF%E7%A8%8B%E4%B9%9F%E4%B8%8D%E4%BC%9A%E6%8C%89-FIFO-%E9%98%9F%E5%88%97%E6%8E%92%E5%BA%8F%E3%80%82%E8%A7%A3%E9%87%8A%E6%8F%90%E4%BE%9B%E8%BF%99%E7%A7%8D%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%9A%84%E5%A5%BD%E5%A4%84%E3%80%82"><span class="toc-number">6.2.</span> <span class="toc-text">7.2. Windows 提供了一种轻量级同步工具，称为简化的读写锁（slim reader-writer locks）。而大多数读写锁实现倾向于优先考虑读者或写者，或者可能使用 FIFO 策略排序等待线程，简化的读写锁既不偏向读者也不偏向写者，等待线程也不会按 FIFO 队列排序。解释提供这种同步工具的好处。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E6%8F%8F%E8%BF%B0%E5%A6%82%E6%9E%9C%E5%B0%86%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9B%BF%E6%8D%A2%E4%B8%BA%E4%BA%92%E6%96%A5%E9%94%81%EF%BC%8C%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E8%BF%9B%E7%A8%8B%E5%9C%A8%E5%9B%BE-7-1-%E5%92%8C%E5%9B%BE-7-2-%E4%B8%AD%E9%9C%80%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%93%AA%E4%BA%9B%E6%9B%B4%E6%94%B9%E3%80%82"><span class="toc-number">6.3.</span> <span class="toc-text">7.3. 描述如果将二进制信号量替换为互斥锁，生产者和消费者进程在图 7.1 和图 7.2 中需要进行哪些更改。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E6%8F%8F%E8%BF%B0%E5%9C%A8%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98%E4%B8%AD%E6%AD%BB%E9%94%81%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%91%E7%94%9F%E7%9A%84%E3%80%82"><span class="toc-number">6.4.</span> <span class="toc-text">7.4. 描述在哲学家就餐问题中死锁是如何发生的。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-%E8%A7%A3%E9%87%8A-Windows-%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E7%8A%B6%E6%80%81%E5%92%8C%E9%9D%9E%E4%BF%A1%E5%8F%B7%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="toc-number">6.5.</span> <span class="toc-text">7.5. 解释 Windows 调度程序对象中的信号状态和非信号状态之间的区别。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-%E5%81%87%E8%AE%BE-val-%E6%98%AF-Linux-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E5%8E%9F%E5%AD%90%E6%95%B4%E6%95%B0%E3%80%82%E4%BB%A5%E4%B8%8B%E6%93%8D%E4%BD%9C%E5%AE%8C%E6%88%90%E5%90%8E-val-%E7%9A%84%E5%80%BC%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">6.6.</span> <span class="toc-text">7.6. 假设 val 是 Linux 系统中的一个原子整数。以下操作完成后 val 的值是多少？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E7%AC%AC9%E7%AB%A0-%E4%B8%BB%E5%86%85%E5%AD%98"><span class="toc-number">7.</span> <span class="toc-text">9. 第9章 主内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E8%AF%B4%E6%98%8E%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E4%B9%8B%E9%97%B4%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%8C%BA%E5%88%AB"><span class="toc-number">7.1.</span> <span class="toc-text">9.1. 说明逻辑地址和物理地址之间的两个区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%A1%B5%E9%9D%A2%E5%A4%A7%E5%B0%8F%E6%80%BB%E6%98%AF2%E7%9A%84%E5%B9%82%EF%BC%9F"><span class="toc-number">7.2.</span> <span class="toc-text">9.2. 为什么页面大小总是2的幂？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E8%80%83%E8%99%91%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E5%B0%86%E7%A8%8B%E5%BA%8F%E5%88%86%E4%B8%BA%E4%B8%A4%E9%83%A8%E5%88%86%EF%BC%9A%E4%BB%A3%E7%A0%81%E5%92%8C%E6%95%B0%E6%8D%AE%E3%80%82CPU-%E7%9F%A5%E9%81%93%E5%AE%83%E9%9C%80%E8%A6%81%E6%8C%87%E4%BB%A4%EF%BC%88%E6%8C%87%E4%BB%A4%E8%8E%B7%E5%8F%96%EF%BC%89%E8%BF%98%E6%98%AF%E6%95%B0%E6%8D%AE%EF%BC%88%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%E6%88%96%E5%AD%98%E5%82%A8%EF%BC%89%E3%80%82%E5%9B%A0%E6%AD%A4%EF%BC%8C%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%A4%E5%AF%B9%E5%9F%BA%E5%9D%80-%E9%99%90%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%9A%E4%B8%80%E4%B8%AA%E7%94%A8%E4%BA%8E%E6%8C%87%E4%BB%A4%EF%BC%8C%E4%B8%80%E4%B8%AA%E7%94%A8%E4%BA%8E%E6%95%B0%E6%8D%AE%E3%80%82%E6%8C%87%E4%BB%A4%E5%9F%BA%E5%9D%80-%E9%99%90%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%B9%E6%98%AF%E8%87%AA%E5%8A%A8%E5%8F%AA%E8%AF%BB%E7%9A%84%EF%BC%8C%E5%9B%A0%E6%AD%A4%E7%A8%8B%E5%BA%8F%E5%8F%AF%E4%BB%A5%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%94%A8%E6%88%B7%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E3%80%82%E8%AE%A8%E8%AE%BA%E8%BF%99%E7%A7%8D%E6%96%B9%E6%A1%88%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E3%80%82"><span class="toc-number">7.3.</span> <span class="toc-text">9.3. 考虑一个可以将程序分为两部分：代码和数据。CPU 知道它需要指令（指令获取）还是数据（数据获取或存储）。因此，提供了两对基址-限址寄存器：一个用于指令，一个用于数据。指令基址-限址寄存器对是自动只读的，因此程序可以在不同用户之间共享。讨论这种方案的优缺点。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-%E8%80%83%E8%99%91%E4%B8%80%E4%B8%AA%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%EF%BC%8C%E5%8C%85%E5%90%AB64%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%8C%E6%AF%8F%E4%B8%AA%E9%A1%B5%E9%9D%A2%E5%8C%85%E5%90%AB1024%E4%B8%AA%E5%AD%97%EF%BC%8C%E6%98%A0%E5%B0%84%E5%88%B0%E4%B8%80%E4%B8%AA%E5%8C%85%E5%90%AB32%E4%B8%AA%E6%A1%86%E6%9E%B6%E7%9A%84%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E4%B8%AD%E3%80%82"><span class="toc-number">7.4.</span> <span class="toc-text">9.4. 考虑一个逻辑地址空间，包含64个页面，每个页面包含1024个字，映射到一个包含32个框架的物理内存中。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-%E5%85%81%E8%AE%B8%E9%A1%B5%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%9D%A1%E7%9B%AE%E6%8C%87%E5%90%91%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%90%8C%E4%B8%80%E9%A1%B5%E9%9D%A2%E6%A1%86%E6%9E%B6%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E5%BD%B1%E5%93%8D%EF%BC%9F%E8%A7%A3%E9%87%8A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E8%BF%99%E7%A7%8D%E5%BD%B1%E5%93%8D%E6%9D%A5%E5%87%8F%E5%B0%91%E5%B0%86%E5%A4%A7%E9%87%8F%E5%86%85%E5%AD%98%E4%BB%8E%E4%B8%80%E4%B8%AA%E5%9C%B0%E6%96%B9%E5%A4%8D%E5%88%B6%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%9C%B0%E6%96%B9%E6%89%80%E9%9C%80%E7%9A%84%E6%97%B6%E9%97%B4%E3%80%82%E6%9B%B4%E6%96%B0%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E4%B8%8A%E7%9A%84%E6%9F%90%E4%B8%AA%E5%AD%97%E8%8A%82%E4%BC%9A%E5%AF%B9%E5%8F%A6%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E4%BA%A7%E7%94%9F%E4%BB%80%E4%B9%88%E5%BD%B1%E5%93%8D%EF%BC%9F"><span class="toc-number">7.5.</span> <span class="toc-text">9.5. 允许页表中的两个条目指向内存中的同一页面框架会有什么影响？解释如何使用这种影响来减少将大量内存从一个地方复制到另一个地方所需的时间。更新一个页面上的某个字节会对另一个页面产生什么影响？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-6-%E7%BB%99%E5%AE%9A%E5%85%AD%E4%B8%AA%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%EF%BC%8C%E5%A4%A7%E5%B0%8F%E5%88%86%E5%88%AB%E4%B8%BA300KB%E3%80%81600KB%E3%80%81350KB%E3%80%81200KB%E3%80%81750KB%E5%92%8C125KB%EF%BC%88%E6%8C%89%E9%A1%BA%E5%BA%8F%EF%BC%89%EF%BC%8C%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87-%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E6%B3%95%E3%80%81%E6%9C%80%E4%BD%B3%E9%80%82%E5%BA%94%E6%B3%95%E5%92%8C%E6%9C%80%E5%B7%AE%E9%80%82%E5%BA%94%E6%B3%95%E6%9D%A5%E6%94%BE%E7%BD%AE%E4%BB%A5%E4%B8%8B%E5%A4%A7%E5%B0%8F%E7%9A%84%E8%BF%9B%E7%A8%8B%EF%BC%9A115KB%E3%80%81500KB%E3%80%81358KB%E3%80%81200KB%E5%92%8C375KB%EF%BC%88%E6%8C%89%E9%A1%BA%E5%BA%8F%EF%BC%89%EF%BC%9F"><span class="toc-number">7.6.</span> <span class="toc-text">9.6. 给定六个内存分区，大小分别为300KB、600KB、350KB、200KB、750KB和125KB（按顺序），如何通过 首次适应法、最佳适应法和最差适应法来放置以下大小的进程：115KB、500KB、358KB、200KB和375KB（按顺序）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-7-%E5%81%87%E8%AE%BE%E9%A1%B5%E5%A4%A7%E5%B0%8F%E4%B8%BA1KB%EF%BC%8C%E4%BB%A5%E4%B8%8B%E5%9C%B0%E5%9D%80%E5%BC%95%E7%94%A8%EF%BC%88%E4%BB%A5%E5%8D%81%E8%BF%9B%E5%88%B6%E7%BB%99%E5%87%BA%EF%BC%89%E7%9A%84%E9%A1%B5%E5%8F%B7%E5%92%8C%E5%81%8F%E7%A7%BB%E9%87%8F%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9A"><span class="toc-number">7.7.</span> <span class="toc-text">9.7. 假设页大小为1KB，以下地址引用（以十进制给出）的页号和偏移量是多少：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E7%AC%AC11%E7%AB%A0-%E5%A4%A7%E5%AE%B9%E9%87%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">8.</span> <span class="toc-text">11. 第11章 大容量存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-%E9%99%A4%E4%BA%86-FCFS-%E8%B0%83%E5%BA%A6%EF%BC%8C%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E5%9C%A8%E5%8D%95%E7%94%A8%E6%88%B7%E7%8E%AF%E5%A2%83%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E7%94%A8%EF%BC%9F%E8%A7%A3%E9%87%8A%E4%BD%A0%E7%9A%84%E7%AD%94%E6%A1%88%E3%80%82"><span class="toc-number">8.1.</span> <span class="toc-text">11.1. 除了 FCFS 调度，磁盘调度在单用户环境中是否有用？解释你的答案。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-%E8%A7%A3%E9%87%8A%E4%B8%BA%E4%BB%80%E4%B9%88-SSTF-%E8%B0%83%E5%BA%A6-%E5%80%BE%E5%90%91%E4%BA%8E%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E4%B8%AD%E9%97%B4%E7%9A%84%E7%A3%81%E9%81%93%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E6%9C%80%E5%86%85%E5%B1%82%E5%92%8C%E6%9C%80%E5%A4%96%E5%B1%82%E7%9A%84%E7%A3%81%E9%81%93%E3%80%82"><span class="toc-number">8.2.</span> <span class="toc-text">11.2. 解释为什么 SSTF 调度 倾向于优先考虑中间的磁道，而不是最内层和最外层的磁道。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%97%8B%E8%BD%AC%E5%BB%B6%E8%BF%9F%E9%80%9A%E5%B8%B8%E4%B8%8D%E8%80%83%E8%99%91%E5%9C%A8%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E4%B8%AD%EF%BC%9F%E5%A6%82%E6%9E%9C%E8%A6%81%E4%BC%98%E5%8C%96%E5%BB%B6%E8%BF%9F%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9-SSTF%E3%80%81SCAN-%E5%92%8C-C-SCAN-%E8%B0%83%E5%BA%A6%EF%BC%9F"><span class="toc-number">8.3.</span> <span class="toc-text">11.3. 为什么旋转延迟通常不考虑在磁盘调度中？如果要优化延迟，如何修改 SSTF、SCAN 和 C-SCAN 调度？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%8E%AF%E5%A2%83%E4%B8%AD%E5%B9%B3%E8%A1%A1%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84-I-O-%E5%88%86%E9%85%8D%E5%88%B0%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E7%A3%81%E7%9B%98%E5%92%8C%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%8A%E5%BE%88%E9%87%8D%E8%A6%81%EF%BC%9F"><span class="toc-number">8.4.</span> <span class="toc-text">11.4. 为什么在多任务环境中平衡文件系统的 I&#x2F;O 分配到系统中的磁盘和控制器上很重要？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-5-%E9%87%8D%E6%96%B0%E8%AF%BB%E5%8F%96%E4%BB%A3%E7%A0%81%E9%A1%B5%E4%BB%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E4%B8%8E%E4%BD%BF%E7%94%A8%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4%E5%AD%98%E5%82%A8%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E6%9D%83%E8%A1%A1%EF%BC%9F"><span class="toc-number">8.5.</span> <span class="toc-text">11.5. 重新读取代码页从文件系统中与使用交换空间存储它们之间有什么权衡？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-6-%E6%98%AF%E5%90%A6%E6%9C%89%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E7%9C%9F%E6%AD%A3%E7%9A%84%E7%A8%B3%E5%AE%9A%E5%AD%98%E5%82%A8%EF%BC%9F%E8%A7%A3%E9%87%8A%E4%BD%A0%E7%9A%84%E7%AD%94%E6%A1%88%E3%80%82"><span class="toc-number">8.6.</span> <span class="toc-text">11.6. 是否有方法实现真正的稳定存储？解释你的答案。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-7-%E6%9C%89%E6%97%B6%E8%AF%B4%E7%A3%81%E5%B8%A6%E6%98%AF%E9%A1%BA%E5%BA%8F%E8%AE%BF%E9%97%AE%E4%BB%8B%E8%B4%A8%EF%BC%8C%E8%80%8C%E7%A1%AC%E7%9B%98%E6%98%AF%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E4%BB%8B%E8%B4%A8%E3%80%82%E4%BA%8B%E5%AE%9E%E4%B8%8A%EF%BC%8C%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87%E6%98%AF%E5%90%A6%E9%80%82%E7%94%A8%E4%BA%8E%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E5%8F%96%E5%86%B3%E4%BA%8E%E4%BC%A0%E8%BE%93%E5%A4%A7%E5%B0%8F%E3%80%82%E6%B5%81%E5%BC%8F%E4%BC%A0%E8%BE%93%E9%80%9F%E7%8E%87%E6%98%AF%E6%8C%87%E6%AD%A3%E5%9C%A8%E8%BF%9B%E8%A1%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E9%80%9F%E7%8E%87%EF%BC%8C%E4%B8%8D%E5%8C%85%E6%8B%AC%E8%AE%BF%E9%97%AE%E5%BB%B6%E8%BF%9F%E7%9A%84%E5%BD%B1%E5%93%8D%E3%80%82%E4%B8%8E%E6%AD%A4%E7%9B%B8%E5%AF%B9%EF%BC%8C%E6%9C%89%E6%95%88%E4%BC%A0%E8%BE%93%E9%80%9F%E7%8E%87-%E6%98%AF%E6%80%BB%E5%AD%97%E8%8A%82%E6%95%B0%E4%B8%8E%E6%80%BB%E7%A7%92%E6%95%B0%E7%9A%84%E6%AF%94%E7%8E%87%EF%BC%8C%E5%8C%85%E6%8B%AC%E8%AF%B8%E5%A6%82%E8%AE%BF%E9%97%AE%E5%BB%B6%E8%BF%9F%E7%AD%89%E5%BC%80%E9%94%80%E6%97%B6%E9%97%B4%E3%80%82"><span class="toc-number">8.7.</span> <span class="toc-text">11.7. 有时说磁带是顺序访问介质，而硬盘是随机访问介质。事实上，存储设备是否适用于随机访问取决于传输大小。流式传输速率是指正在进行的数据传输速率，不包括访问延迟的影响。与此相对，有效传输速率 是总字节数与总秒数的比率，包括诸如访问延迟等开销时间。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-8-RAID-1-%E7%BB%84%E7%BB%87%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%AF%94-RAID-0-%E7%BB%84%E7%BB%87%EF%BC%88%E6%97%A0%E5%86%97%E4%BD%99%E6%9D%A1%E5%B8%A6%E6%95%B0%E6%8D%AE%EF%BC%89%E5%9C%A8%E8%AF%BB%E5%8F%96%E8%AF%B7%E6%B1%82%E6%97%B6%E6%8F%90%E4%BE%9B%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%80%A7%E8%83%BD%EF%BC%9F%E5%A6%82%E6%9E%9C%E6%98%AF%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">8.8.</span> <span class="toc-text">11.8. RAID 1 组织是否可以比 RAID 0 组织（无冗余条带数据）在读取请求时提供更好的性能？如果是，如何实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-9-%E7%BB%99%E5%87%BA%E4%BD%BF%E7%94%A8-HDD-%E4%BD%9C%E4%B8%BA%E4%BA%8C%E7%BA%A7%E5%AD%98%E5%82%A8%E7%9A%84%E4%B8%89%E4%B8%AA%E7%90%86%E7%94%B1%E3%80%82"><span class="toc-number">8.9.</span> <span class="toc-text">11.9. 给出使用 HDD 作为二级存储的三个理由。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-10-%E7%BB%99%E5%87%BA%E4%BD%BF%E7%94%A8-NVM-%E8%AE%BE%E5%A4%87%E4%BD%9C%E4%B8%BA%E4%BA%8C%E7%BA%A7%E5%AD%98%E5%82%A8%E7%9A%84%E4%B8%89%E4%B8%AA%E7%90%86%E7%94%B1%E3%80%82"><span class="toc-number">8.10.</span> <span class="toc-text">11.10. 给出使用 NVM 设备作为二级存储的三个理由。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E7%AC%AC12%E7%AB%A0-I-O%E7%B3%BB%E7%BB%9F"><span class="toc-number">9.</span> <span class="toc-text">12. 第12章 I&#x2F;O系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-%E5%B0%86%E5%8A%9F%E8%83%BD%E6%94%BE%E5%9C%A8%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%AD%E8%80%8C%E9%9D%9E%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E4%B8%89%E4%B8%AA%E4%BC%98%E7%82%B9%E5%92%8C%E4%B8%89%E4%B8%AA%E7%BC%BA%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">9.1.</span> <span class="toc-text">12.1. 将功能放在设备控制器中而非内核中的三个优点和三个缺点是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-%E7%AC%AC12-2%E8%8A%82%E4%B8%AD%E6%89%8B%E6%91%87%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%BE%8B%E5%AD%90%E4%BD%BF%E7%94%A8%E4%BA%86%E4%B8%A4%E4%B8%AA%E4%BD%8D%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%BF%99%E7%A2%8C%E4%BD%8D%E5%92%8C%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E5%B0%B1%E7%BB%AA%E4%BD%8D%E3%80%82%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%8F%AA%E7%94%A8%E4%B8%80%E4%B8%AA%E4%BD%8D%E6%9D%A5%E5%AE%9E%E7%8E%B0%E8%BF%99%E4%B8%AA%E6%8F%A1%E6%89%8B%EF%BC%9F%E5%A6%82%E6%9E%9C%E5%8F%AF%E4%BB%A5%EF%BC%8C%E8%AF%B7%E6%8F%8F%E8%BF%B0%E5%8D%8F%E8%AE%AE%E3%80%82%E5%A6%82%E6%9E%9C%E4%B8%8D%E8%A1%8C%EF%BC%8C%E8%AF%B7%E8%A7%A3%E9%87%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E4%B8%AA%E4%BD%8D%E6%98%AF%E4%B8%8D%E5%A4%9F%E7%9A%84%E3%80%82"><span class="toc-number">9.2.</span> <span class="toc-text">12.2. 第12.2节中手摇信号的例子使用了两个位：一个忙碌位和一个命令就绪位。是否可以只用一个位来实现这个握手？如果可以，请描述协议。如果不行，请解释为什么一个位是不够的。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E4%B8%AA%E7%B3%BB%E7%BB%9F%E5%8F%AF%E8%83%BD%E4%BC%9A%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%AD%E9%A9%B1%E5%8A%A8I-O%E6%9D%A5%E7%AE%A1%E7%90%86%E5%8D%95%E4%B8%AA%E4%B8%B2%E5%8F%A3%EF%BC%8C%E8%80%8C%E4%BD%BF%E7%94%A8%E8%BD%AE%E8%AF%A2I-O%E6%9D%A5%E7%AE%A1%E7%90%86%E5%89%8D%E7%AB%AF%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%88%E5%A6%82%E7%BB%88%E7%AB%AF%E9%9B%86%E7%BA%BF%E5%99%A8%EF%BC%89%EF%BC%9F"><span class="toc-number">9.3.</span> <span class="toc-text">12.3. 为什么一个系统可能会使用中断驱动I&#x2F;O来管理单个串口，而使用轮询I&#x2F;O来管理前端处理器（如终端集线器）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-%E5%A6%82%E6%9E%9C%E5%A4%84%E7%90%86%E5%99%A8%E5%9C%A8I-O%E5%AE%8C%E6%88%90%E4%B9%8B%E5%89%8D%E5%A4%9A%E6%AC%A1%E8%BF%AD%E4%BB%A3%E7%B9%81%E5%BF%99%E7%AD%89%E5%BE%85%E5%BE%AA%E7%8E%AF%EF%BC%8C%E8%BD%AE%E8%AF%A2I-O%E5%AE%8C%E6%88%90%E4%BC%9A%E6%B5%AA%E8%B4%B9%E5%A4%A7%E9%87%8FCPU%E5%91%A8%E6%9C%9F%E3%80%82%E4%BD%86%E6%98%AF%E5%A6%82%E6%9E%9CI-O%E8%AE%BE%E5%A4%87%E5%B7%B2%E5%87%86%E5%A4%87%E5%A5%BD%E6%9C%8D%E5%8A%A1%EF%BC%8C%E8%BD%AE%E8%AF%A2%E5%8F%AF%E8%83%BD%E6%AF%94%E6%8D%95%E6%8D%89%E5%92%8C%E5%88%86%E6%B4%BE%E4%B8%AD%E6%96%AD%E6%9B%B4%E9%AB%98%E6%95%88%E3%80%82%E6%8F%8F%E8%BF%B0%E4%B8%80%E7%A7%8D%E6%B7%B7%E5%90%88%E7%AD%96%E7%95%A5%EF%BC%8C%E7%BB%93%E5%90%88%E8%BD%AE%E8%AF%A2%E3%80%81%E7%9D%A1%E7%9C%A0%E5%92%8C%E4%B8%AD%E6%96%AD%E6%9D%A5%E5%A4%84%E7%90%86I-O%E8%AE%BE%E5%A4%87%E6%9C%8D%E5%8A%A1%E3%80%82%E5%AF%B9%E4%BA%8E%E8%BF%99%E4%B8%89%E7%A7%8D%E7%AD%96%E7%95%A5%EF%BC%88%E7%BA%AF%E8%BD%AE%E8%AF%A2%E3%80%81%E7%BA%AF%E4%B8%AD%E6%96%AD%E3%80%81%E6%B7%B7%E5%90%88%E7%AD%96%E7%95%A5%EF%BC%89%EF%BC%8C%E6%8F%8F%E8%BF%B0%E4%B8%80%E7%A7%8D%E5%9C%A8%E8%BF%99%E7%A7%8D%E7%AD%96%E7%95%A5%E6%AF%94%E5%85%B6%E4%BB%96%E4%B8%A4%E7%A7%8D%E6%9B%B4%E9%AB%98%E6%95%88%E7%9A%84%E8%AE%A1%E7%AE%97%E7%8E%AF%E5%A2%83%E3%80%82"><span class="toc-number">9.4.</span> <span class="toc-text">12.4. 如果处理器在I&#x2F;O完成之前多次迭代繁忙等待循环，轮询I&#x2F;O完成会浪费大量CPU周期。但是如果I&#x2F;O设备已准备好服务，轮询可能比捕捉和分派中断更高效。描述一种混合策略，结合轮询、睡眠和中断来处理I&#x2F;O设备服务。对于这三种策略（纯轮询、纯中断、混合策略），描述一种在这种策略比其他两种更高效的计算环境。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-5-DMA%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E7%B3%BB%E7%BB%9F%E5%B9%B6%E5%8F%91%E6%80%A7%EF%BC%9F%E5%AE%83%E5%A6%82%E4%BD%95%E4%BD%BF%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%8F%98%E5%BE%97%E5%A4%8D%E6%9D%82%EF%BC%9F"><span class="toc-number">9.5.</span> <span class="toc-text">12.5. DMA如何提高系统并发性？它如何使硬件设计变得复杂？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-6-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9A%8F%E7%9D%80CPU%E9%80%9F%E5%BA%A6%E7%9A%84%E6%8F%90%E9%AB%98%EF%BC%8C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF%E5%92%8C%E8%AE%BE%E5%A4%87%E9%80%9F%E5%BA%A6%E4%B9%9F%E9%9C%80%E8%A6%81%E6%8F%90%E5%8D%87%EF%BC%9F"><span class="toc-number">9.6.</span> <span class="toc-text">12.6. 为什么随着CPU速度的提高，系统总线和设备速度也需要提升？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-7-%E5%9C%A8STREAMS%E6%93%8D%E4%BD%9C%E4%B8%AD%EF%BC%8C%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%AB%AF%E5%92%8C%E6%B5%81%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">9.7.</span> <span class="toc-text">12.7. 在STREAMS操作中，驱动程序端和流模块的区别是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E7%AC%AC13%E7%AB%A0-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.</span> <span class="toc-text">13. 第13章 文件系统接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-%E4%B8%80%E4%BA%9B%E7%B3%BB%E7%BB%9F%E5%9C%A8%E7%94%A8%E6%88%B7%E6%B3%A8%E9%94%80%E6%88%96%E4%BD%9C%E4%B8%9A%E7%BB%88%E6%AD%A2%E6%97%B6%E8%87%AA%E5%8A%A8%E5%88%A0%E9%99%A4%E6%89%80%E6%9C%89%E7%94%A8%E6%88%B7%E6%96%87%E4%BB%B6%EF%BC%8C%E9%99%A4%E9%9D%9E%E7%94%A8%E6%88%B7%E6%98%8E%E7%A1%AE%E8%A6%81%E6%B1%82%E4%BF%9D%E7%95%99%E5%AE%83%E4%BB%AC%E3%80%82%E5%85%B6%E4%BB%96%E7%B3%BB%E7%BB%9F%E5%88%99%E4%BF%9D%E7%95%99%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%EF%BC%8C%E9%99%A4%E9%9D%9E%E7%94%A8%E6%88%B7%E6%98%8E%E7%A1%AE%E5%88%A0%E9%99%A4%E5%AE%83%E4%BB%AC%E3%80%82%E8%AE%A8%E8%AE%BA%E8%BF%99%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%E7%9A%84%E7%9B%B8%E5%AF%B9%E4%BC%98%E7%BC%BA%E7%82%B9%E3%80%82"><span class="toc-number">10.1.</span> <span class="toc-text">13.1. 一些系统在用户注销或作业终止时自动删除所有用户文件，除非用户明确要求保留它们。其他系统则保留所有文件，除非用户明确删除它们。讨论这两种方法的相对优缺点。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%BA%9B%E7%B3%BB%E7%BB%9F%E4%BC%9A%E8%B7%9F%E8%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%8C%E8%80%8C%E5%85%B6%E4%BB%96%E7%B3%BB%E7%BB%9F%E5%88%99%E5%B0%86%E5%85%B6%E7%95%99%E7%BB%99%E7%94%A8%E6%88%B7%EF%BC%8C%E6%88%96%E8%80%85%E6%A0%B9%E6%9C%AC%E4%B8%8D%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%A7%8D%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%EF%BC%9F%E5%93%AA%E4%B8%AA%E7%B3%BB%E7%BB%9F%E6%9B%B4%E2%80%9C%E5%A5%BD%E2%80%9D%EF%BC%9F"><span class="toc-number">10.2.</span> <span class="toc-text">13.2. 为什么有些系统会跟踪文件的类型，而其他系统则将其留给用户，或者根本不实现多种文件类型？哪个系统更“好”？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-%E5%90%8C%E6%A0%B7%EF%BC%8C%E6%9C%89%E4%BA%9B%E7%B3%BB%E7%BB%9F%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E8%80%8C%E5%85%B6%E4%BB%96%E7%B3%BB%E7%BB%9F%E5%88%99%E4%BB%85%E6%94%AF%E6%8C%81%E5%AD%97%E8%8A%82%E6%B5%81%E3%80%82%E6%AF%8F%E7%A7%8D%E6%96%B9%E6%B3%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">10.3.</span> <span class="toc-text">13.3. 同样，有些系统支持多种类型的文件数据结构，而其他系统则仅支持字节流。每种方法的优缺点是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4-%E4%BD%A0%E8%83%BD%E5%90%A6%E7%94%A8%E5%8D%95%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%E5%A4%9A%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%EF%BC%8C%E5%85%B6%E4%B8%AD%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E4%BB%BB%E6%84%8F%E9%95%BF%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D%EF%BC%9F%E5%A6%82%E6%9E%9C%E5%8F%AF%E4%BB%A5%EF%BC%8C%E8%AF%B7%E8%A7%A3%E9%87%8A%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%EF%BC%8C%E6%AF%94%E8%BE%83%E8%BF%99%E7%A7%8D%E6%96%B9%E6%A1%88%E5%92%8C%E5%A4%9A%E7%BA%A7%E7%9B%AE%E5%BD%95%E6%96%B9%E6%A1%88%E3%80%82%E5%A6%82%E6%9E%9C%E4%B8%8D%E8%A1%8C%EF%BC%8C%E8%AF%B7%E8%A7%A3%E9%87%8A%E6%98%AF%E4%BB%80%E4%B9%88%E9%98%BB%E7%A2%8D%E4%BA%86%E6%A8%A1%E6%8B%9F%E7%9A%84%E6%88%90%E5%8A%9F%E3%80%82%E5%A6%82%E6%9E%9C%E6%96%87%E4%BB%B6%E5%90%8D%E9%99%90%E5%88%B6%E4%B8%BA%E4%B8%83%E4%B8%AA%E5%AD%97%E7%AC%A6%EF%BC%8C%E4%BD%A0%E7%9A%84%E7%AD%94%E6%A1%88%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96%EF%BC%9F"><span class="toc-number">10.4.</span> <span class="toc-text">13.4. 你能否用单级目录结构模拟多级目录结构，其中可以使用任意长的文件名？如果可以，请解释如何做到，比较这种方案和多级目录方案。如果不行，请解释是什么阻碍了模拟的成功。如果文件名限制为七个字符，你的答案会有什么变化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-5-%E8%A7%A3%E9%87%8A-open-%E5%92%8C-close-%E6%93%8D%E4%BD%9C%E7%9A%84%E7%9B%AE%E7%9A%84%E3%80%82"><span class="toc-number">10.5.</span> <span class="toc-text">13.5. 解释 open() 和 close() 操作的目的。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-6-%E5%9C%A8%E6%9F%90%E4%BA%9B%E7%B3%BB%E7%BB%9F%E4%B8%AD%EF%BC%8C%E5%AD%90%E7%9B%AE%E5%BD%95%E5%8F%AF%E4%BB%A5%E5%83%8F%E6%99%AE%E9%80%9A%E6%96%87%E4%BB%B6%E4%B8%80%E6%A0%B7%E8%A2%AB%E6%8E%88%E6%9D%83%E7%94%A8%E6%88%B7%E8%AF%BB%E5%8F%96%E5%92%8C%E5%86%99%E5%85%A5%E3%80%82"><span class="toc-number">10.6.</span> <span class="toc-text">13.6. 在某些系统中，子目录可以像普通文件一样被授权用户读取和写入。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-7-%E8%80%83%E8%99%91%E4%B8%80%E4%B8%AA%E6%94%AF%E6%8C%81-5-000-%E4%B8%AA%E7%94%A8%E6%88%B7%E7%9A%84%E7%B3%BB%E7%BB%9F%E3%80%82%E5%81%87%E8%AE%BE%E4%BD%A0%E5%B8%8C%E6%9C%9B%E8%AE%A9-4-990-%E4%B8%AA%E7%94%A8%E6%88%B7%E8%83%BD%E5%A4%9F%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E3%80%82"><span class="toc-number">10.7.</span> <span class="toc-text">13.7. 考虑一个支持 5,000 个用户的系统。假设你希望让 4,990 个用户能够访问一个文件。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-8-%E7%A0%94%E7%A9%B6%E4%BA%BA%E5%91%98%E5%BB%BA%E8%AE%AE%EF%BC%8C%E4%B8%8E%E6%AF%8F%E4%B8%AA%E6%96%87%E4%BB%B6%E5%85%B3%E8%81%94%E4%B8%80%E4%B8%AA%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%88%97%E8%A1%A8%EF%BC%88%E6%8C%87%E5%AE%9A%E5%93%AA%E4%BA%9B%E7%94%A8%E6%88%B7%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E6%96%87%E4%BB%B6%E5%8F%8A%E5%85%B6%E6%96%B9%E5%BC%8F%EF%BC%89%E7%9B%B8%E6%AF%94%EF%BC%8C%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E4%B8%BA%E6%AF%8F%E4%B8%AA%E7%94%A8%E6%88%B7%E5%85%B3%E8%81%94%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E6%8E%A7%E5%88%B6%E5%88%97%E8%A1%A8%EF%BC%88%E6%8C%87%E5%AE%9A%E7%94%A8%E6%88%B7%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E5%93%AA%E4%BA%9B%E6%96%87%E4%BB%B6%E5%8F%8A%E5%85%B6%E6%96%B9%E5%BC%8F%EF%BC%89%E3%80%82%E8%AE%A8%E8%AE%BA%E8%BF%99%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%A1%88%E7%9A%84%E7%9B%B8%E5%AF%B9%E4%BC%98%E7%BC%BA%E7%82%B9%E3%80%82"><span class="toc-number">10.8.</span> <span class="toc-text">13.8. 研究人员建议，与每个文件关联一个访问控制列表（指定哪些用户可以访问文件及其方式）相比，我们应该为每个用户关联一个用户控制列表（指定用户可以访问哪些文件及其方式）。讨论这两种方案的相对优缺点。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E7%AC%AC14%E7%AB%A0-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0"><span class="toc-number">11.</span> <span class="toc-text">14. 第14章 文件系统实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-%E8%80%83%E8%99%91%E4%B8%80%E4%B8%AA%E5%BD%93%E5%89%8D%E7%94%B1-100-%E4%B8%AA%E5%9D%97%E7%BB%84%E6%88%90%E7%9A%84%E6%96%87%E4%BB%B6%E3%80%82%E5%81%87%E8%AE%BE%E6%96%87%E4%BB%B6%E6%8E%A7%E5%88%B6%E5%9D%97%EF%BC%88%E4%BB%A5%E5%8F%8A%E5%9C%A8%E7%B4%A2%E5%BC%95%E5%88%86%E9%85%8D%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E7%B4%A2%E5%BC%95%E5%9D%97%EF%BC%89%E5%B7%B2%E7%BB%8F%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E3%80%82%E8%AE%A1%E7%AE%97%E5%AF%B9%E4%BA%8E%E4%BB%A5%E4%B8%8B%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%9D%97%E6%89%80%E9%9C%80%E7%9A%84%E7%A3%81%E7%9B%98-I-O-%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%EF%BC%8C%E9%92%88%E5%AF%B9%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E3%80%81%E9%93%BE%E6%8E%A5%E5%88%86%E9%85%8D%E5%92%8C%E7%B4%A2%E5%BC%95%EF%BC%88%E5%8D%95%E7%BA%A7%EF%BC%89%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%EF%BC%9A"><span class="toc-number">11.1.</span> <span class="toc-text">14.1. 考虑一个当前由 100 个块组成的文件。假设文件控制块（以及在索引分配情况下的索引块）已经在内存中。计算对于以下条件的块所需的磁盘 I&#x2F;O 操作次数，针对连续分配、链接分配和索引（单级）分配策略：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D%E7%9A%84%E4%BD%8D%E5%9B%BE%E5%BF%85%E9%A1%BB%E5%AD%98%E5%82%A8%E5%9C%A8%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87%E4%B8%8A%EF%BC%8C%E8%80%8C%E4%B8%8D%E8%83%BD%E5%AD%98%E5%82%A8%E5%9C%A8%E4%B8%BB%E5%86%85%E5%AD%98%E4%B8%AD%EF%BC%9F"><span class="toc-number">11.2.</span> <span class="toc-text">14.2. 为什么文件分配的位图必须存储在外部存储设备上，而不能存储在主内存中？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-%E8%80%83%E8%99%91%E4%B8%80%E4%B8%AA%E6%94%AF%E6%8C%81%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E3%80%81%E9%93%BE%E6%8E%A5%E5%88%86%E9%85%8D%E5%92%8C%E7%B4%A2%E5%BC%95%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%E7%9A%84%E7%B3%BB%E7%BB%9F%E3%80%82%E5%9C%A8%E5%86%B3%E5%AE%9A%E5%93%AA%E7%A7%8D%E7%AD%96%E7%95%A5%E6%9C%80%E9%80%82%E5%90%88%E7%89%B9%E5%AE%9A%E6%96%87%E4%BB%B6%E6%97%B6%EF%BC%8C%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E6%A0%87%E5%87%86%EF%BC%9F"><span class="toc-number">11.3.</span> <span class="toc-text">14.3. 考虑一个支持连续分配、链接分配和索引分配策略的系统。在决定哪种策略最适合特定文件时，应该使用什么标准？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%9A%84%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%E6%98%AF%E7%94%A8%E6%88%B7%E5%BF%85%E9%A1%BB%E9%A2%84%E5%85%88%E4%B8%BA%E6%AF%8F%E4%B8%AA%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D%E8%B6%B3%E5%A4%9F%E7%9A%84%E7%A9%BA%E9%97%B4%E3%80%82%E5%A6%82%E6%9E%9C%E6%96%87%E4%BB%B6%E5%A2%9E%E9%95%BF%E8%B6%85%E8%BF%87%E5%88%86%E9%85%8D%E7%9A%84%E7%A9%BA%E9%97%B4%EF%BC%8C%E5%88%99%E5%BF%85%E9%A1%BB%E9%87%87%E5%8F%96%E7%89%B9%E6%AE%8A%E6%8E%AA%E6%96%BD%E3%80%82%E8%A7%A3%E5%86%B3%E6%AD%A4%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95%E6%98%AF%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%EF%BC%8C%E5%8C%85%E5%90%AB%E4%B8%80%E4%B8%AA%E6%8C%87%E5%AE%9A%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E8%BF%9E%E7%BB%AD%E5%8C%BA%E5%9F%9F%E3%80%82%E5%A6%82%E6%9E%9C%E8%AF%A5%E5%8C%BA%E5%9F%9F%E5%B7%B2%E6%BB%A1%EF%BC%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E4%B8%8E%E5%88%9D%E5%A7%8B%E8%BF%9E%E7%BB%AD%E5%8C%BA%E5%9F%9F%E9%93%BE%E6%8E%A5%E7%9A%84%E6%BA%A2%E5%87%BA%E5%8C%BA%E5%9F%9F%E3%80%82%E5%A6%82%E6%9E%9C%E6%BA%A2%E5%87%BA%E5%8C%BA%E5%9F%9F%E5%B7%B2%E6%BB%A1%EF%BC%8C%E5%88%99%E4%BC%9A%E5%88%86%E9%85%8D%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%BA%A2%E5%87%BA%E5%8C%BA%E5%9F%9F%E3%80%82%E5%B0%86%E6%AD%A4%E6%96%87%E4%BB%B6%E5%AE%9E%E7%8E%B0%E4%B8%8E%E6%A0%87%E5%87%86%E7%9A%84%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E5%92%8C%E9%93%BE%E6%8E%A5%E5%88%86%E9%85%8D%E5%AE%9E%E7%8E%B0%E8%BF%9B%E8%A1%8C%E6%AF%94%E8%BE%83%E3%80%82"><span class="toc-number">11.4.</span> <span class="toc-text">14.4. 连续分配的一个问题是用户必须预先为每个文件分配足够的空间。如果文件增长超过分配的空间，则必须采取特殊措施。解决此问题的一种方法是定义一个文件结构，包含一个指定大小的初始连续区域。如果该区域已满，操作系统会自动定义一个与初始连续区域链接的溢出区域。如果溢出区域已满，则会分配另一个溢出区域。将此文件实现与标准的连续分配和链接分配实现进行比较。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-5-%E7%BC%93%E5%AD%98%E5%A6%82%E4%BD%95%E5%B8%AE%E5%8A%A9%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E7%B3%BB%E7%BB%9F%E4%B8%8D%E4%BD%BF%E7%94%A8%E6%9B%B4%E5%A4%9A%E6%88%96%E6%9B%B4%E5%A4%A7%E7%9A%84%E7%BC%93%E5%AD%98%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%AE%83%E4%BB%AC%E5%A6%82%E6%AD%A4%E6%9C%89%E7%94%A8%E7%9A%84%E8%AF%9D%EF%BC%9F"><span class="toc-number">11.5.</span> <span class="toc-text">14.5. 缓存如何帮助提高性能？为什么系统不使用更多或更大的缓存，如果它们如此有用的话？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-6-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E9%83%A8%E8%A1%A8%E5%AF%B9%E7%94%A8%E6%88%B7%E6%9C%89%E5%88%A9%EF%BC%9F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%BA%E6%AD%A4%E9%9C%80%E8%A6%81%E6%89%BF%E6%8B%85%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BB%A3%E4%BB%B7%EF%BC%9F"><span class="toc-number">11.6.</span> <span class="toc-text">14.6. 为什么操作系统动态分配内部表对用户有利？操作系统为此需要承担什么样的代价？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E7%AC%AC15%E7%AB%A0-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">12.</span> <span class="toc-text">15. 第15章 文件系统内部实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-%E8%A7%A3%E9%87%8A-VFS-%E5%B1%82%E5%A6%82%E4%BD%95%E4%BD%BF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%83%BD%E5%A4%9F%E8%BD%BB%E6%9D%BE%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E3%80%82"><span class="toc-number">12.1.</span> <span class="toc-text">15.1. 解释 VFS 层如何使操作系统能够轻松支持多种类型的文件系统。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8%E4%B8%80%E4%B8%AA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E8%A6%81%E6%9C%89%E5%A4%9A%E7%A7%8D%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">12.2.</span> <span class="toc-text">15.2. 为什么在一个系统中要有多种文件系统类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-3-%E5%9C%A8%E5%AE%9E%E7%8E%B0%E4%BA%86-procfs-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-%E7%9A%84-Unix-%E6%88%96-Linux-%E7%B3%BB%E7%BB%9F%E4%B8%8A%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-procfs-%E6%8E%A5%E5%8F%A3-%E6%9D%A5%E6%8E%A2%E7%B4%A2%E8%BF%9B%E7%A8%8B%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4%EF%BC%9F%E9%80%9A%E8%BF%87%E6%AD%A4%E6%8E%A5%E5%8F%A3%E5%8F%AF%E4%BB%A5%E6%9F%A5%E7%9C%8B%E5%93%AA%E4%BA%9B%E8%BF%9B%E7%A8%8B%E6%96%B9%E9%9D%A2%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%9F%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89-procfs-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%8C%E5%A6%82%E4%BD%95%E6%94%B6%E9%9B%86%E7%9B%B8%E5%90%8C%E7%9A%84%E4%BF%A1%E6%81%AF%EF%BC%9F"><span class="toc-number">12.3.</span> <span class="toc-text">15.3. 在实现了 procfs 文件系统 的 Unix 或 Linux 系统上，如何使用 procfs 接口 来探索进程名称空间？通过此接口可以查看哪些进程方面的内容？如果没有 procfs 文件系统，如何收集相同的信息？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-4-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%BA%9B%E7%B3%BB%E7%BB%9F%E5%B0%86%E6%8C%82%E8%BD%BD%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%9B%86%E6%88%90%E5%88%B0%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%91%BD%E5%90%8D%E7%BB%93%E6%9E%84%E4%B8%AD%EF%BC%8C%E8%80%8C%E5%85%B6%E4%BB%96%E7%B3%BB%E7%BB%9F%E5%88%99%E4%BD%BF%E7%94%A8%E5%8D%95%E7%8B%AC%E7%9A%84%E5%91%BD%E5%90%8D%E6%96%B9%E6%B3%95%E6%9D%A5%E5%91%BD%E5%90%8D%E6%8C%82%E8%BD%BD%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%9F"><span class="toc-number">12.4.</span> <span class="toc-text">15.4. 为什么有些系统将挂载的文件系统集成到根文件系统命名结构中，而其他系统则使用单独的命名方法来命名挂载的文件系统？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-5-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E8%AE%BE%E6%96%BD%EF%BC%8C%E5%A6%82-ftp%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%83%8F-NFS-%E8%BF%99%E6%A0%B7%E7%9A%84%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%BC%9A%E8%A2%AB%E5%88%9B%E5%BB%BA%EF%BC%9F"><span class="toc-number">12.5.</span> <span class="toc-text">15.5. 给定一个远程文件访问设施，如 ftp，为什么像 NFS 这样的远程文件系统会被创建？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/09/OS_Words/OS_Words/" title="OS_Words">OS_Words</a><time datetime="2025-06-08T16:00:00.000Z" title="发表于 2025-06-09 00:00:00">2025-06-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%A0%E9%A2%98/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%A0%E9%A2%98/" title="操作系统习题">操作系统习题</a><time datetime="2025-06-08T14:19:00.000Z" title="发表于 2025-06-08 22:19:00">2025-06-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/07/%E7%AC%AC%E5%85%AB%E7%AB%A0%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E7%AC%AC%E5%85%AB%E7%AB%A0%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/" title="第八章文件管理">第八章文件管理</a><time datetime="2025-06-07T14:19:00.000Z" title="发表于 2025-06-07 22:19:00">2025-06-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/07/%E7%AC%AC%E4%B8%83%E7%AB%A0IO%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/%E7%AC%AC%E4%B8%83%E7%AB%A0IO%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/" title="第七章IO设备管理">第七章IO设备管理</a><time datetime="2025-06-07T14:09:00.000Z" title="发表于 2025-06-07 22:09:00">2025-06-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/07/%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="第六章虚拟内存管理">第六章虚拟内存管理</a><time datetime="2025-06-07T14:05:00.000Z" title="发表于 2025-06-07 22:05:00">2025-06-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By PIQUE</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>